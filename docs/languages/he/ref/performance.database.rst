.. _performance.database:

Zend_Db שימוש נכון למיטב הביצועים
=================================

*Zend_Db* הינה בסיס שכבות למחלקות אשר מטפלות במסדי נתונים, ונועדה
כדי לתת API נפוץ לפעולות אשר נעשות על גבי ה SQL. *Zend_Db_Table* הינה מחלקת
מידע לניתוב טבלאות מסדי נתונים, אשר מהוות בתור מחלקה כשכבה
עליונה לכל המחלקות אשר נמצאות תחתיה, שנועדו למטרת ביצוע פעולות
טבלאויות מול מסד הנתונים. מאחר ואלו מחלקות שאר מהוות שכבה
עליונה לכל המחלקות תחתיהם, "והקסם" שהם מבצעות ברקע כדי לבצע את
הפעולות שלהם, הם לעתים יכולים לגרום לבעיות משמעותיות בביצועים
של המערכת.

.. _performance.database.tableMetadata:

אין ניתן להפחית את כמות המשאבים שצורכת המחלקה של Zend_Db_Table בזמן שליפת נתונים אודות טבלה/טבלאות?
---------------------------------------------------------------------------------------------------

כדי לייעל ולפשט את השימוש כמה שניתן, ועדיין לתמוך בתרשים מסד
הנתונים גם כשהוא משתנה תוך כדי פיתוח, *Zend_Db_Table* מבצעת מספר דברים
מאחורי הקלעים: בשימוש הראשון, היא שולפת את כל התרשים של מסד
הנתונים ושומרת את זה באובייקט מסויים לשימוש חוזר. פעולה זו היא
בדרך כלל צורכת הרבה משאבים ויכולה לגרום לצוואר בקבוק במערכות,
ולא משנה באיזה מסד נתונים משתמשים.

למרבה המזל ישנם טכניקות שונות לשיפור התפעול במצבים כאלו.

.. _performance.database.tableMetadata.cache:

שימוש במטמון אודות הנתונים של המסד
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*Zend_Db_Table* יכולה להשתמש ב *Zend_Cache* כדי לשמור את הנתונים אודות
התרשים של מסד הנתונים שנשלף במטמון. בדרך זו יהיה מהיר יותר לגשת
לנתונים ולצרוך פחות משאבים בכל פעם שמנסים לגשת לנתונים אודות
מסד הנתונים שנשלפו.

הדוקומנטציה של :ref:`Zend_Db_Table מכילה מידע אודות שימוש במטמון במחלקה
זו. <zend.db.table.metadata.caching>`.

.. _performance.database.tableMetadata.hardcoding:

כתיבה ידנית של המידע אודות הטבלה בהגדרות של אותה טבלה
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

מאז גרסא 1.7.0, *Zend_Db_Table* מאפשר תמיכה ב :ref:`כתיבה ידנית של המידע
אודות הטבלה בהגדרות של אותה טבלה <zend.db.table.metadata.caching.hardcoding>`. זהו
שימוש מתקדם יותר, ורצוי להשתמש בו רק כשתרשים הטבלה ידוע מראש
וסביר להניח שהוא לא השתנה מאוחר יותר, או שתוכלו להמשיך ולעדכן
את ההגדרות של הטבלה בכל פעם שתרשים הטבלה השתנה.

.. _performance.database.select:

פקודות SQL אשר נוצרו בעזרת Zend_Db_Select לא משתמשות באינדקסים של הטבלה; כיצד ניתן לשפר זאת?
--------------------------------------------------------------------------------------------

*Zend_Db_Select* בהחלט עושה עבודה טובה במה שהוא אמור לעשות. אך למרות
זאת, במידה והנכם מבצעים שאילתות מסובכות למסד הנתונים אשר
מכילות חיבורים בין טבלאות ותתי שאילתות, זה יכול להיות לפעמים
תמים בנושא זה.

.. _performance.database.select.writeyourown:

כתבו את פונקציות השליפה כנגד מסד הנתונים בעצמכם
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

התשובה האמיתית היחידה היא כתיבת פונקציות שליפת הנתונים שלכם
בעצמכם; *Zend_Db* לא מחייב שימוש ב *Zend_Db_Select*, לכן כתיבת שאילות שליפת
הנתונים שלכם בעצמכם היא בהחלט גישה תקינה,

הריצו את פקודת ה *EXPLAIN* על גבי השאילתות שלכם על מנת לבדוק כמה
וכמה גישות עד שתוכלו להגיע לשאילתה עם התוצאות הטובות ביותר.

אם השאילתה דורשת הזנה של משתנים בתור נתונים, השתמשו ב"שומרי
מקום" בשאילתות, והשתמשו בשילוב של *vsprintf* ו *array_walk* כדי להזין את
אותם המשתנים אל השאילתות. לדוגמא:

.. code-block::
   :linenos:

   // $adapter is the DB adapter. In Zend_Db_Table, retrieve
   // it using $this->getAdapter().
   $sql = vsprintf(
       self::SELECT_FOO,
       array_walk($values, array($adapter, 'quoteInto'))
   );


