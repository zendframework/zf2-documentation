.. _zend.db.table:

Zend_Db_Table
=============

.. _zend.db.table.introduction:

Класс таблицы - введение
------------------------

Класс Zend_Db_Table является объектно-ориентированным интерфейсом к
таблицам баз данных. Он предоставляет методы для многих общих
операций над таблицами. Базовый класс является расширяемым,
поэтому вы можете добавлять свою логику.

Решением Zend_Db_Table является реализация паттерна `Table Data Gateway`_. Это
решение также включает в себя класс, реализующий паттерн `Row Data
Gateway`_.

.. _zend.db.table.defining:

Определение класса таблицы
--------------------------

Для каждой таблицы в БД, к которой нужен доступ, определяется
класс, наследующий от Zend_Db_Table_Abstract.

.. _zend.db.table.defining.table-schema:

Определение имени и схемы таблицы
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Указывайте таблицу, для которой определен этот класс,
используя защищенную переменную ``$_name``. Переменная должна
содержать имя таблицы в том виде, в котором она представлена в
БД.

.. _zend.db.table.defining.table-schema.example1:

.. rubric:: Объявление класса таблицы с явным определением имени таблицы

.. code-block:: php
   :linenos:

   class Bugs extends Zend_Db_Table_Abstract
   {
       protected $_name = 'bugs';
   }


Если вы не определили имя таблицы, то по умолчанию оно равно
имени класса. Если вы предпочитаете этот путь, то имя класса
должно иметь то же написание, что и имя таблицы в БД.

.. _zend.db.table.defining.table-schema.example:

.. rubric:: Объявление класса таблицы с неявным определением имени таблицы

.. code-block:: php
   :linenos:

   class bugs extends Zend_Db_Table_Abstract
   {
       // имя таблицы соответствует имени класса
   }


Вы можете также объявить схему таблицы в защищенной
переменной ``$_schema`` или через добавленное перед именем таблицы
имя схемы в свойстве ``$_name``. Схема, указанная с помощью свойства
``$_name``, имеет более высокий приоритет, чем схема, объявленная с
помощью свойства ``$_schema``. В некоторых СУРБД вместо термина
"схема" используются термины "база данных" или "пространство
таблиц", они используются аналогичным образом.

.. _zend.db.table.defining.table-schema.example3:

.. rubric:: Объявление класса таблицы со схемой

.. code-block:: php
   :linenos:

   // Первый способ:
   class Bugs extends Zend_Db_Table_Abstract
   {
       protected $_schema = 'bug_db';
       protected $_name   = 'bugs';
   }

   // Второй способ:
   class Bugs extends Zend_Db_Table_Abstract
   {
       protected $_name = 'bug_db.bugs';
   }

   // Если в обоих свойствах $_name м $_schema была объявлена схема,
   // то указанная в $_name имеет больший приоритет:
   class Bugs extends Zend_Db_Table_Abstract
   {
       protected $_name   = 'bug_db.bugs';
       protected $_schema = 'ignored';
   }


Схема и таблица могут быть указаны через конфигурационные
директивы конструктора, которые замещают собой любые значения
по умолчанию, определенные с помощью свойств ``$_name`` и ``$_schema``.
Спецификация схемы, данная через директиву *name*, замещает собой
любое значение, переданное через опцию *schema*.

.. _zend.db.table.defining.table-schema.example.constructor:

.. rubric:: Объявление имен таблицы и схемы во время инстанцирования

.. code-block:: php
   :linenos:

   class Bugs extends Zend_Db_Table_Abstract
   {
   }

   // Первый способ:

   $tableBugs = new Bugs(array('name' => 'bugs', 'schema' => 'bug_db'));

   // Второй способ:

   $tableBugs = new Bugs(array('name' => 'bug_db.bugs');

   // Если в обоих опциях 'name' и 'schema' была объявлена схема,
   // то указанная в 'name' имеет больший приоритет:

   $tableBugs = new Bugs(array('name' => 'bug_db.bugs',
                               'schema' => 'ignored');


Если вы не указали имя схемы, то по умолчанию это будет схема, к
которой подключен ваш экземпляр адаптера БД.

.. _zend.db.table.defining.primary-key:

Определение первичного ключа таблицы
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Каждая таблица должна иметь первичный ключ. Вы можете объявить
столбец для первичного ключа, используя защищенную переменную
``$_primary``. Это может быть строка с именем одного столбца или
массив имен столбцов, если первичный ключ является составным.

.. _zend.db.table.defining.primary-key.example:

.. rubric:: Пример определения первичного ключа

.. code-block:: php
   :linenos:

   class Bugs extends Zend_Db_Table_Abstract
   {
       protected $_name = 'bugs';
       protected $_primary = 'bug_id';
   }


Если вы не задали первичный ключ, то Zend_Db_Table_Abstract пытается
определить его, основываясь на данных, полученных через метод
*describeTable()*.

.. note::

   Класс таблицы должен знать, какой столбец (или столбцы)
   используются для уникальной адресации строк. Если в классе
   таблицы или аргументах конструктора (а также в метаданных
   таблицы, полученных через метод *describeTable()*) не были указаны
   первичные ключи, то эта таблица не может использоваться
   через Zend_Db_Table.

.. _zend.db.table.defining.setup:

Переопределение методов установки таблицы
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Когда создается экземпляр класса таблицы, конструктор
вызывает ряд защищенных методов, инициализирующих метаданные
для таблицы. Вы можете переопределить любые из этих методов
для того, чтобы явно определить эти метаданные. Помните, что в
конце должен вызываться родительский метод.

.. _zend.db.table.defining.setup.example:

.. rubric:: Пример переопределения метода \_setupTableName()

.. code-block:: php
   :linenos:


   class Bugs extends Zend_Db_Table_Abstract
   {
       protected function _setupTableName()
       {
           $this->_name = 'bugs';
           parent::_setupTableName();
       }
   }


Методы установки могут быть переопределены следующим образом:

- *_setupDatabaseAdapter()* проверяет, был ли предоставлен адаптер БД, и
  извлекает используемый по умолчанию адаптер из реестра, если
  необходимо. Переопределив этот метод, вы можете установить
  адаптер БД из других источников.

- *_setupTableName()* по умолчанию получает имя таблицы из имени класса.
  Переопределив этот метод, вы можете установить имя таблицы до
  того, как будут произведены эти действия по умолчанию.

- *_setupMetadata()* устанавливает схему, если имя таблицы содержит
  структуру "schema.table", вызывает *describeTable()* для получения
  метаданных, по умолчанию определяет массив столбцов ``$_cols``,
  полученных через *describeTable()*. Переопределелив этот метод, вы
  можете устанавливать столбцы самостоятельно.

- *_setupPrimaryKey()* по умолчанию устанавливает столбцы первичного
  ключа, полученные через *describeTable()*, и проверяет, входят ли
  столбцы первичного ключа в массив ``$_cols``. Переопределив этот
  метод, вы можете устанавливать столбцы первичного ключа.

.. _zend.db.table.initialization:

Инициализация таблицы
^^^^^^^^^^^^^^^^^^^^^

Если при создании объекта таблицы требуется выполнять код,
реализующий логику приложения, то вы можете поместить этот код
в метод *init()*, который вызвается после того, как были обработаны
все метаданные таблицы. Рекомендуется использовать этот
способ вместо переопределения метода *__construct*, если только не
требуется изменять метаданные программным путем.



      .. _zend.db.table.defining.init.usage.example:

      .. rubric:: Пример использования метода init()

      .. code-block:: php
         :linenos:


         class Bugs extends Zend_Db_Table_Abstract
         {
             protected $_observer;

             protected function init()
             {
                 $this->_observer = new MyObserverClass();
             }
         }




.. _zend.db.table.constructing:

Создание экземпляра класса таблицы
----------------------------------

До того, как начать использование класса таблицы, создайте его
экземпляр, используя конструктор. Единственным аргументом
конструктора является массив опций. Наиболее важной опцией
для конструктора является экземпляр адаптера БД,
представляющий текущее соединение к какой-либо СУРБД. Есть три
способа передачи адаптера БД классу таблицы, и эти три способа
описаны ниже:

.. _zend.db.table.constructing.adapter:

Установка адаптера БД
^^^^^^^^^^^^^^^^^^^^^

Первым способом предоставления адаптера БД классу таблицы
является передача объекта типа Zend_Db_Adapter_Abstract в массиве опций
под ключом *'db'*.

.. _zend.db.table.constructing.adapter.example:

.. rubric:: Пример создания экземпляра таблицы с использованием объекта адаптера

.. code-block:: php
   :linenos:


   $db = Zend_Db::factory('PDO_MYSQL', $options);

   $table = new Bugs(array('db' => $db));


.. _zend.db.table.constructing.default-adapter:

Установка используемого по умолчанию адаптера БД
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Вторым способом предоставления адаптера БД классу таблицы
является декларирование объекта типа Zend_Db_Adapter_Abstract как
используемого по умолчанию для всех экземпляров таблиц в
вашем приложении. Вы можете делать это через статический метод
*Zend_Db_Table_Abstract::setDefaultAdapter()*. Его аргументом является объект типа
Zend_Db_Adapter_Abstract.

.. _zend.db.table.constructing.default-adapter.example:

.. rubric:: Пример создания экземпляра таблицы с адаптером, используемым по умолчанию

.. code-block:: php
   :linenos:


   $db = Zend_Db::factory('PDO_MYSQL', $options);
   Zend_Db_Table_Abstract::setDefaultAdapter($db);

   // Далее...

   $table = new Bugs();


Может быть удобным создавать объект адаптера БД в центральной
части вашего приложения - например, в загрузочном коде - и затем
сохранять его как адаптер, используемый по умолчанию. Это дает
возможность быть уверенным в том, что во всем приложении
используется один и тот же экземпляр адаптера. Но установка
адаптера, используемого по умолчанию, ограничена одним
экземпляром адаптера.

.. _zend.db.table.constructing.registry:

Хранение адаптера БД в реестре
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Третий способ передачи адаптера БД классу таблицы - передача
строки в массиве опций под ключом *'db'*. Эта строка используется
как ключ для статического экземпляра Zend_Registry, в котором под
этим ключом должен храниться объект типа Zend_Db_Adapter_Abstract.

.. _zend.db.table.constructing.registry.example:

.. rubric:: Пример создания экземпляра таблицы с использованием ключа реестра

.. code-block:: php
   :linenos:


   $db = Zend_Db::factory('PDO_MYSQL', $options);
   Zend_Registry::set('my_db', $db);

   // Далее...

   $table = new Bugs(array('db' => 'my_db'));


Как и в случае установки адаптера, используемого по умолчанию,
это дает возможность быть уверенным в том, что во всем
приложении используется один и тот же адаптер, но
использование реестра является более гибким, т.к. вы можете
хранить в нем более одного экземпляра адаптера. Экземпляр
адаптера является индивидуальным для конкретной СУРБД и
экземпляра БД. Если в вашем приложении необходимо
подключаться к нескольким БД или даже различным СУРБД, то вам
нужно использовать несколько адаптеров.

.. _zend.db.table.insert:

Добавление строк в таблицу
--------------------------

Вы можете использовать объект таблицы для добавления строк в
таблицу БД, на которой основан объект таблицы. Для этого
используйте метод *insert()* в объекте таблицы. Аргументом
является ассоциативный массив, содержащий имена столбцов и
соответствующие им значения.

.. _zend.db.table.insert.example:

.. rubric:: Пример добавления строк в таблицу

.. code-block:: php
   :linenos:

   $table = new Bugs();

   $data = array(
       'created_on'      => '2007-03-22',
       'bug_description' => 'Something wrong',
       'bug_status'      => 'NEW'
   );

   $table->insert($data);


По умолчанию значения в вашем массиве данных добавляются как
буквенные значения, с использованием параметров. Если вам
нужно, чтобы они интерпретировались как выражения SQL, то
необходимо обозначить их отличие от простых строк. Для этого
используйте объекты типа Zend_Db_Expr.

.. _zend.db.table.insert.example-expr:

.. rubric:: Пример добавления выражений в таблицу

.. code-block:: php
   :linenos:

   $table = new Bugs();

   $data = array(
       'created_on'      => new Zend_Db_Expr('CURDATE()'),
       'bug_description' => 'Something wrong',
       'bug_status'      => 'NEW'
   );


В примере добавления строки выше предполагается, что таблица
имеет автоинкрементный первичный ключ. Это принятое по
умолчанию поведение Zend_Db_Table_Abstract, но есть и другие типы
первичных ключей. Следующий раздел описывает, как
поддерживаются различные типы первичных ключей.

.. _zend.db.table.insert.key-auto:

Использование таблицы с автоинкрементным ключом
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Автоинкрементный первичный ключ генерирует уникальное
целочисленное значение, если вы опустите столбец для
первичного ключа в своем операторе *INSERT*.

Если защищенная переменная в Zend_Db_Table_Abstract ``$_sequence`` имеет булево
значение ``TRUE``, то класс предполагает, что таблица имеет
автоинкрементный столбец.

.. _zend.db.table.insert.key-auto.example:

.. rubric:: Пример объявления таблицы с автоинкрементным первичным ключом

.. code-block:: php
   :linenos:

   class Bugs extends Zend_Db_Table_Abstract
   {
       protected $_name = 'bugs';

       // Это значение по умолчанию присутствует в Zend_Db_Table_Abstract,
       // устанавливать его не обязательно
       protected $_sequence = true;
   }


Примерами СУРБД, поддерживающих автоинкрементные первичные
ключи являются MySQL, Microsoft SQL Server и SQLite.

PostgreSQL имеет нотацию *SERIAL*, которая неявно определяет
последовательность, основанную на имени таблицы и столбца, и
использует ее для генерации значений ключа при добавлении
новых строк. IBM DB2 имеет нотацию *IDENTITY* которая работает
аналогичным образом. Если вы используете одну из этих нотаций,
то интерпретируйте свой класс Zend_Db_Table как имеющий
автоинкрементный столбец, при этом члена ``$_sequence`` должен иметь
значение ``TRUE``.

.. _zend.db.table.insert.key-sequence:

Использование таблицы с последовательностью
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Последовательность (sequence) является объектом базы данных,
генерирующим уникальные значения, которые могут
использоваться как значения уникальных ключей в одной и более
таблицах БД.

Если вы присвоили ``$_sequence`` строковое значение, то Zend_Db_Table_Abstract
считает строку именем объекта последовательности в БД.
Последовательность запускается для генерации нового
значения, и это значение используется в операции *INSERT*.

.. _zend.db.table.insert.key-sequence.example:

.. rubric:: Пример объявления таблицы с последовательностью

.. code-block:: php
   :linenos:

   class Bugs extends Zend_Db_Table_Abstract
   {
       protected $_name = 'bugs';

       protected $_sequence = 'bug_sequence';
   }


Примерами СУРБД, поддерживающих объекты последовательностей
являются Oracle, PostgreSQL и IBM DB2.

PostgreSQL и IBM DB2 также имеют синтаксис, который неявно определяет
последовательности и связывает их со столбцами. Если вы
используете эту нотацию, то интерпретируйте таблицу как
имеющую автоинкрементный ключевой столбец. Задавайте имя
последовательности в виде строки только в тех случаях, когда
вы собираетесь явно вызывать последовательности для
получения следующего значения ключа.

.. _zend.db.table.insert.key-natural:

Использование таблицы с естественным ключом
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Некоторые таблицы имеют естественные ключи. Это означает, что
ключ не генерируется автоматически таблицей или
последовательностью. В этом случае вы должны установить
значение первичного ключа.

Если вы присвоили ``$_sequence`` булево значение ``FALSE``, то
Zend_Db_Table_Abstract считает, что таблица имеет естественный первичный
ключ. Вы должны предоставлять значения для столбцов
первичного ключа в массиве данных для метода *insert()*, иначе
метод бросает исключение Zend_Db_Table_Exception.

.. _zend.db.table.insert.key-natural.example:

.. rubric:: Пример объявления таблицы с естественным ключом

.. code-block:: php
   :linenos:

   class BugStatus extends Zend_Db_Table_Abstract
   {
       protected $_name = 'bug_status';

       protected $_sequence = false;
   }


.. note::

   Все СУРБД поддерживают таблицы с естественными ключами.
   Примеры таблиц, часто объявляемых как имеющие естественные
   ключи: справочные таблицы, таблицы пересечений в отношениях
   "многие-ко-многим", большинство таблиц с составными ключами.

.. _zend.db.table.update:

Обновление строк в таблице
--------------------------

Вы можете обновлять строки в таблице БД, используя метод *update*
класса таблицы. Этот метод принимает два аргумента: первым
является ассоциативный массив столбцов, которые требуется
изменить, и новых значений, присваиваемых этим столбцам;
вторым - выражение SQL, которое используется в предложении *WHERE* в
качестве условия изменения строки в операции *UPDATE*.

.. _zend.db.table.update.example:

.. rubric:: Пример обновления строк в таблице

.. code-block:: php
   :linenos:

   $table = new Bugs();

   $data = array(
       'updated_on'      => '2007-03-23',
       'bug_status'      => 'FIXED'
   );

   $where = $table->getAdapter()->quoteInto('bug_id = ?', 1234);

   $table->update($data, $where);


Поскольку метод таблицы *update()* в свою очередь использует метод
адаптера БД :ref:`update() <zend.db.adapter.update>`, то второй аргумент может
быть массивом SQL-выражений. Выражения объединяются как булевы
условия через оператор *AND*.

.. note::

   Значения и идентификаторы в SQL-выражении не заключаются в
   кавычки автоматически. Если имеются значения или
   идентификаторы, которые требуют заключения в кавычки, то вы
   должны произвести его сами. Используйте методы *quote()*, *quoteInto()*
   и *quoteIdentifier()* адаптера БД.

.. _zend.db.table.delete:

Удаление строк из таблицы
-------------------------

Вы можете удалять строки из таблицы базы данных, используя
метод *delete()*. Этот метод принимает один аргумент, являющийся
SQL-выражением, который используется в предложении *WHERE* в
качестве условия, по которому удаляются строки.

.. _zend.db.table.delete.example:

.. rubric:: Пример удаления строк из таблицы

.. code-block:: php
   :linenos:

   $table = new Bugs();

   $where = $table->getAdapter()->quoteInto('bug_id = ?', 1235);

   $table->delete($where);


Поскольку метод таблицы в свою очередь использует метод *delete()*
адаптера БД, то второй аргумент может быть массивом
SQL-выражений. Выражения объединяются как булевы условия через
оператор *AND*.

.. note::

   Значения и идентификаторы в SQL-выражении не заключаются в
   кавычки автоматически. Если имеются значения или
   идентификаторы, которые требуют заключения в кавычки, то вы
   должны произвести его сами. Используйте методы *quote()*, *quoteInto()*
   и *quoteIdentifier()* адаптера БД.

.. _zend.db.table.find:

Извлечение строк по первичному ключу
------------------------------------

Вы можете запрашивать из таблицы БД строки, соответствующие
определенным значениям в первичном ключе, используя метод
*find()*. Первым аргументом этого метода является единственное
значение или массив значений, сопоставляемых с первичным
ключом таблицы.

.. _zend.db.table.find.example:

.. rubric:: Пример извлечения строк по значениям первичного ключа

.. code-block:: php
   :linenos:

   $table = new Bugs();

   // Запрос одной строки
   // Возвращает набор строк (Rowset)
   $rows = $table->find(1234);

   // Запрос нескольких строк
   // Также возвращает набор строк (Rowset)
   $rows = $table->find(array(1234, 5678));


Если вы задали одно значение, то метод вернет максимум одну
строку, потому что первичный ключ не может содержать
повторяющиеся значения и должна быть максимум одна строка в
таблице БД, соответствующая данному значению. Если вы задали
несколько значений, то метод вернет максимум столько строк,
сколько несовпадающих значений было задано.

Метод *find()* может возвращать меньше строк, чем было задано
значений для первичного ключа, если для некоторых значений нет
соответствующих строк в таблице БД. Метод может даже вернуть
нулевое количество строк. Поскольку количество возвращаемых
строк является переменным, то метод *find()* возвращает объект
типа Zend_Db_Table_Rowset_Abstract (набор строк).

Если первичный ключ является составным, т.e. он состоит из
нескольких столбцов, то можно задать добавочные столбцы как
дополнительные аргументы метода *find()*. Вы должны передать
столько аргументов, сколько столбцов в первичном ключе
таблицы.

Для того чтобы найти несколько строк с составным первичным
ключом, передавайте массив для каждого из аргументов. Все эти
массивы должны иметь одно и то же количество элементов.
Значения из всех массивов объединяются в "кортежи" в порядке
следования; например, первые элементы каждого массива
определяют значение первого составного первичного ключа,
вторые элементы - второго составного ключа и т.д.

.. _zend.db.table.find.example-compound:

.. rubric:: Пример извлечения строк по значениям составного первичного ключа

Вызов метода *find()* ниже для поиска нескольких строк может
соответствовать двум строкам в БД. Первая строка должна иметь
значение первичного ключа (1234, 'ABC'), вторая - (5678, 'DEF').

.. code-block:: php
   :linenos:

   class BugsProducts extends Zend_Db_Table_Abstract
   {
       protected $_name = 'bugs_products';
       protected $_primary = array('bug_id', 'product_id');
   }

   $table = new BugsProducts();

   // Запрашивает единственную строку через составной первичный ключ
   // Возвращает набор строк (Rowset)
   $rows = $table->find(1234, 'ABC');

   // Запрашивает несколько строк через составной первичный ключ
   // Также возвращает набор строк (Rowset)
   $rows = $table->find(array(1234, 5678), array('ABC', 'DEF'));


.. _zend.db.table.fetch-all:

Извлечение наборов строк
------------------------

.. _zend.db.table.fetch-all.select:

API для произведения выборки
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. warning::

   API для операций извлечения был изменен для того, чтобы объект
   *Zend_Db_Table_Select* мог изменять запрос. Тем не менее, не
   рекомендуемый сейчас вариант использования *fetchRow()* и *fetchAll()*
   будет работать без изменений.

   Следующие варианты являются корректными и функционально
   идентичными, но, тем не менее, рекомендуется обновить свой
   код с тем, чтобы получить преимущества нового подхода.



      .. code-block:: php
         :linenos:


         // Извлечение набора строк
         $rows = $table->fetchAll('bug_status = "NEW"', 'bug_id ASC', 10, 0);
         $rows = $table->fetchAll($table->select()->where('bug_status = ?', 'NEW')
                                                  ->order('bug_id ASC')
                                                  ->limit(10, 0));

         // Извлечение одной строки
         $row = $table->fetchRow('bug_status = "NEW"', 'bug_id ASC');
         $row = $table->fetchRow($table->select()->where('bug_status = ?', 'NEW')
                                                 ->order('bug_id ASC'));






Объект ``Zend_Db_Table_Select`` является расширением объекта ``Zend_Db_Select``,
который накладывает некоторые специфические ограничения на
запрос. Ниже перечислены дополнительные возможности и
ограничения этого класса:

- Вы **можете** выбрать возвращение набора столбцов запросами
  fetchRow и fetchAll. Это дает преимущества в плане оптимизации там,
  где извлечение большого набора строк со всеми столбцами было
  бы не желательным.

- Вы **можете** указывать столбцы, которые определяют выражения
  в таблице. Но это также означает, что возвращаемый объект
  строки или набора строк будет доступен только для чтения и к
  нему не могут применяться операции сохранения. Объект строки
  *Zend_Db_Table_Row* со статусом ``readOnly`` будет бросать исключение при
  попытке произвести операцию сохранения (метод *save()*).

- Вы **можете** разрешить предложения JOIN в выборке для поиска в
  нескольких таблицах.

- Вы **не можете** указывать столбцы из присоединенных таблиц в
  качестве возвращаемых в строке/наборе строк. Попытка сделать
  это вызовет ошибку PHP. Это сделано для того, чтобы
  гарантировать целостность *Zend_Db_Table*, т.е. *Zend_Db_Table_Row* должен
  содержать столбцы только из той таблицы, которую
  представляет данный объект *Zend_Db_Table*.





      .. _zend.db.table.qry.rows.set.simple.usage.example:

      .. rubric:: Простое использование

      .. code-block:: php
         :linenos:


         $table = new Bugs();

         $select = $table->select();
         $select->where('bug_status = ?', 'NEW');

         $rows = $table->fetchAll($select);




В данной компоненте поддерживается fluent interface, поэтому пример
выше может быть переписан в более краткой форме.





      .. _zend.db.table.qry.rows.set.fluent.interface.example:

      .. rubric:: Пример использования fluent interface

      .. code-block:: php
         :linenos:


         $table = new Bugs();

         $rows =
             $table->fetchAll($table->select()->where('bug_status = ?', 'NEW'));




.. _zend.db.table.fetch-all.usage:

Извлечение набора строк
^^^^^^^^^^^^^^^^^^^^^^^

Вы можете извлекать наборы строк, используя любое другое
условие, отличное от значения первичного ключа, через метод
*fetchAll()* класса таблицы. Этот метод возвращает объект типа
*Zend_Db_Table_Rowset_Abstract*.

.. _zend.db.table.qry.rows.set.finding.row.example:

.. rubric:: Пример поиска строк по выражению

.. code-block:: php
   :linenos:


   $table = new Bugs();

   $select = $table->select()->where('bug_status = ?', 'NEW');

   $rows = $table->fetchAll($select);


Вы можете также передавать условие для сортировки, которое
используется в предложении *ORDER BY*, и целочисленные значения
смещения и количества строк для предложения *LIMIT* или
эквивалентной ему логики в СУРБД, не поддерживающих синтаксис
*LIMIT*.

.. _zend.db.table.fetch-all.example2:

.. rubric:: Пример поиска строк по выражению

.. code-block:: php
   :linenos:


   $table = new Bugs();

   $order  = 'bug_id';

   // Требуется вернуть строки начиная с 21-ой и кончая 30-й
   $count  = 10;
   $offset = 20;

   $select = $table->select()->where(array('bug_status = ?' => 'NEW'))
                             ->order($order)
                             ->limit($count, $offset);

   $rows = $table->fetchAll($select);


Все агрументы в примере выше являются опциональными. Если вы
опустите предложение ORDER, то строки из таблицы будут
возвращаться в непредсказуемом порядке. Если не было
установлено предложение LIMIT, то вы получите все
соответствующие предложению WHERE строки из таблицы.

.. _zend.db.table.advanced.usage:

Расширенное использование
^^^^^^^^^^^^^^^^^^^^^^^^^

Для более точных и оптимизированных запросов может
потребоваться ограничить количество столбцов, возвращаемых в
строке/наборе строк. Это может быть достигнуто путем передачи
предложения FROM объекту выборки.





      .. _zend.db.table.qry.rows.set.retrieving.a.example:

      .. rubric:: Извлечение определенных столбцов

      .. code-block:: php
         :linenos:

         $table = new Bugs();

         $select = $table->select();
         $select->from($table, array('bug_id', 'bug_description'))
                ->where('bug_status = ?', 'NEW');

         $rows = $table->fetchAll($select);




.. important::

   Полученный набор строк будет содержать строки, которые
   по-прежнему являются "рабочими", только они содержат не все
   столбцы таблицы. Если для неполной строки был вызван метод
   save(), то будут изменены только доступные в объекте столбцы.

Вы можете также указывать выражения в предложении FROM, но в этом случае будуте получать строки/наборы строк, доступные только для чтения. В этом примере мы будем возвращать строки из таблицы Bugs, которые показывают количество ошибок, сообщенное конкретным пользователем. Обратите внимание на предложение GROUP. Столбец 'count' будет доступен в объекте строки, и к нему можно обращаться так же, как если бы он был частью схемы.





      .. _zend.db.table.qry.rows.set.retrieving.b.example:

      .. rubric:: Извлечение выражений как столбцов

      .. code-block:: php
         :linenos:

         $table = new Bugs();

         $select = $table->select();
         $select->from($table,
                       array('COUNT(reported_by) as `count`', 'reported_by'))
                ->where('bug_status = ?', 'NEW')
                ->group('reported_by');

         $rows = $table->fetchAll($select);


Вы можете использовать поиск как часть вашего запроса для
дальнейшей детализации ваших операций извлечения. В этом
примере таблица Accounts используется для поиска всех новых
ошибок, о которых сообщил пользователь 'Bob'.





      .. _zend.db.table.qry.rows.set.refine.example:

      .. rubric:: Использование таблицы поиска для фильтрации результатов, возвращаемых fetchAll()

      .. code-block:: php
         :linenos:

         $table = new Bugs();

         $select = $table->select();
         $select->where('bug_status = ?', 'NEW')
                ->join('accounts', 'accounts.account_name = bugs.reported_by')
                ->where('accounts.account_name = ?', 'Bob');

         $rows = $table->fetchAll($select);




Класс ``Zend_Db_Table_Select`` главным образом используется для
соблюдения и проверки корректности запроса. Тем не менее,
могут быть определенные случаи, когда нужна большая гибкость
компоненты Zend_Db_Table_Row и не требуется доступная для чтения или
удаления строка. Для этого отдельного случая использования
возможно получение строки/набора строк путем передачи
значения false методу setIntegrityCheck(). В результате строка/набор строк
будет возвращаться в "заблокированном" состоянии, это значит,
что save(), delete() и методы для установки значений полей будут
бросать исключения.

.. _zend.db.table.qry.rows.set.integrity.example:

.. rubric:: Отключение проверки целостности в Zend_Db_Table_Select для получения объединенных строк

.. code-block:: php
   :linenos:

   $table = new Bugs();

   $select = $table->select()->setIntegrityCheck(false);
   $select->where('bug_status = ?', 'NEW')
          ->join('accounts',
                 'accounts.account_name = bugs.reported_by',
                 'account_name')
          ->where('accounts.account_name = ?', 'Bob');

   $rows = $table->fetchAll($select);


.. _zend.db.table.fetch-row:

Извлечение одной строки
-----------------------

Вы можете запрашивать одну строку, используя условия,
аналогичные тем, что используются в методе *fetchAll()*.

.. _zend.db.table.fetch-row.example1:

.. rubric:: Пример поиска одной строки по выражению

.. code-block:: php
   :linenos:

   $table = new Bugs();

   $select  = $table->select()->where('bug_status = ?', 'NEW')
                              ->order('bug_id');

   $row = $table->fetchRow($select);


Этот метод возвращает объект типа Zend_Db_Table_Row_Abstract. Если по
заданному вами условию поиска не найдено ни одной строки в
таблице БД, то *fetchRow()* вернет значение ``NULL``.

.. _zend.db.table.info:

Получение метаданных таблицы
----------------------------

Класс Zend_Db_Table_Abstract предоставляет некоторую информацию о его
метаданных. Метод *info()* возвращает массив с данными о таблице,
ее столбцах, первичном ключе и другие метаданные.

.. _zend.db.table.info.example:

.. rubric:: Пример получения имени таблицы

.. code-block:: php
   :linenos:


   $table = new Bugs();

   $info = $table->info();

   echo "The table name is " . $info['name'] . "\n";


Ключи массива, возвращаемого методом *info()*, описаны ниже.

- **name** => имя таблицы

- **cols** => массив имен столбцов в таблице

- **primary** => массив имен столбцов в первичном ключе

- **metadata** => ассоциативный массив, включающий в себя имена
  столбцов и соответствующие им данные о столбцах. Это
  информация, возвращаемая методом *describeTable()*.

- **rowClass** => имя определенного класса, используемого для
  объектов строк, возвращаемых методами данного экземпляра
  таблицы. По умолчанию это Zend_Db_Table_Row.

- **rowsetClass** => имя определенного класса, используемого для
  объектов наборов строк, возвращаемых методами данного
  экземпляра таблицы. По умолчанию это Zend_Db_Table_Rowset.

- **referenceMap** => ассоциативный массив с данными о ссылках на другие
  таблицы. См. :ref:` <zend.db.table.relationships.defining>`.

- **dependentTables** => массив имен классов таблиц, на которые ссылается
  данная таблица. См. :ref:` <zend.db.table.relationships.defining>`.

- **schema** => имя схемы (базы данных, пространства таблиц) для
  данной таблицы.

.. _zend.db.table.metadata.caching:

Кэширование метаданных таблицы
------------------------------

По умолчанию *Zend_Db_Table_Abstract* производит запрос к БД для
определения :ref:`метаданных таблицы <zend.db.table.info>` во время
инстанцирования объекта таблицы. Т.е. когда создается новый
объект таблицы, поведением по умолчанию является извлечение
метаданных таблицы из БД через метод *describeTable()*.

В некоторых условиях, особенно когда к одной и той же таблице
БД создается много объектов таблиц, произведение запросов для
получения метаданных для каждого экземпляря может быть
нежелательным с точки зрения производительности. В таких
случаях можно производить кэширование метаданных таблицы,
полученных из БД.

Есть два основных способа кэширования:



   - **Вызов метода Zend_Db_Table_Abstract::setDefaultMetadataCache()**- Это позволяет
     разработчику единовременно установить объект кэша,
     используемый в всех классах таблиц.

   - **Конфигурирование Zend_Db_Table_Abstract::__construct()**- Это позволяет
     разработчику установить объект кэша для определенного
     экземпляра класса таблицы.

В обоих случаях определением кэша может быть ``NULL`` (т.е. не
используется кэширование) или экземпляр класса :ref:`Zend_Cache_Core
<zend.cache.frontends.core>`. Эти методы могут использоваться вместе для
того, чтобы использовать по умолчанию определенный объект
кэша и при этом иметь возможность изменять его для конкретного
объекта таблицы.

.. _zend.db.table.metadata.caching-default:

.. rubric:: Кэширование метаданных по умолчанию для всех объектов таблиц

Следующий код показывает, как установить объект кэша,
используемый по умолчанию во всех объектах таблиц:

.. code-block:: php
   :linenos:

   // Сначала создается объект кэша
   $frontendOptions = array(
       'automatic_serialization' => true
       );

   $backendOptions  = array(
       'cacheDir'                => 'cacheDir'
       );

   $cache = Zend_Cache::factory('Core',
                                'File',
                                $frontendOptions,
                                $backendOptions);


   // Далее, объект кэша устанавливается в качестве используемого
   // во всех объектах таблиц
   Zend_Db_Table_Abstract::setDefaultMetadataCache($cache);


   // Класс таблицы
   class Bugs extends Zend_Db_Table_Abstract
   {
       // ...
   }


   // Каждый экземпляр таблицы Bugs теперь использует
   // кэширование метаданных по умолчанию
   $bugs = new Bugs();


.. _zend.db.table.metadata.caching-instance:

.. rubric:: Кэширование метаданных для одного объекта таблицы

Следующий код показывает, как устанавливается кэширование
метаданных для одного конкретного объекта таблицы:

.. code-block:: php
   :linenos:

   // Сначала создается объект кэша
   $frontendOptions = array(
       'automatic_serialization' => true
       );

   $backendOptions  = array(
       'cacheDir'                => 'cacheDir'
       );

   $cache = Zend_Cache::factory('Core',
                                'File',
                                $frontendOptions,
                                $backendOptions);

   // Класс таблицы
   class Bugs extends Zend_Db_Table_Abstract
   {
       // ...
   }


   // Экземпляр конфигурируется при инстанцировании
   $bugs = new Bugs(array('metadataCache' => $cache));


.. note::

   **Автоматическая сериализация через фронтэнд кэша**

   Поскольку информация, возвращаемая методом адаптера
   describeTable(), является массивом, то убедитесь, что опция
   *automatic_serialization* установлена в ``TRUE`` для фронтэнда *Zend_Cache_Core*.

Несмотря на то, что в примерах выше используется *Zend_Cache_Backend_File*,
разработчики могут использовать другие бэкэнды, наиболее
подходящие в данной ситуации. Более подробную информацию
читайте в разделе :ref:`Zend_Cache <zend.cache>`.

.. _zend.db.table.extending:

Расширение класса таблицы
-------------------------

.. _zend.db.table.extending.row-rowset:

Использование собственных классов строки и набора строк
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

По умолчанию методы класса таблицы возвращают наборы строк в
экземплярах класса Zend_Db_Table_Rowset, и эти наборы строк содержат в
себе коллекции экземпляров класса Zend_Db_Table_Row. Вы можете указать
альтернативные классы, используемые вместо них, но в любом
случае они должны наследовать от классов Zend_Db_Table_Rowset_Abstract и
Zend_Db_Table_Row_Abstract соответственно.

Вы можете указать классы строки и набора строк в массиве опций
конструктора таблицы под ключами *'rowClass'* и *'rowsetClass'*
соответственно. Задавайте имена классов в виде обычных строк.

.. _zend.db.table.extending.row-rowset.example:

.. rubric:: Пример указания классов строки и набора строк

.. code-block:: php
   :linenos:

   class My_Row extends Zend_Db_Table_Row_Abstract
   {
       ...
   }

   class My_Rowset extends Zend_Db_Table_Rowset_Abstract
   {
       ...
   }

   $table = new Bugs(
       array(
           'rowClass'    => 'My_Row',
           'rowsetClass' => 'My_Rowset'
       )
   );

   $where = $table->getAdapter()->quoteInto('bug_status = ?', 'NEW')

   // Возвращает объект типа My_Rowset,
   // содержащий массив объектов типа My_Row
   $rows = $table->fetchAll($where);


Вы можете сменить используемые классы, указав их через методы
*setRowClass()* и *setRowsetClass()*. Это изменение применяется к создаваемым
впоследствии строкам и наборам строк и не влияет на класс
объектов строк и наборов строк, созданных ранее.

.. _zend.db.table.extending.row-rowset.example2:

.. rubric:: Пример смены используемых для строк и наборов строк классов

.. code-block:: php
   :linenos:

   $table = new Bugs();

   $where = $table->getAdapter()->quoteInto('bug_status = ?', 'NEW')

   // Возвращает объект типа Zend_Db_Table_Rowset,
   // содержащий массив объектов типа Zend_Db_Table_Row.
   $rowsStandard = $table->fetchAll($where);

   $table->setRowClass('My_Row');
   $table->setRowsetClass('My_Rowset');

   // Возвращает объект типа My_Rowset,
   // содержащий массив объектов типа My_Row.
   $rowsCustom = $table->fetchAll($where);

   // Объект $rowsStandard по прежнему существует и не изменился.


Более подробную информацию о классах строки и набора строк
ищите в :ref:` <zend.db.table.row>` и :ref:` <zend.db.table.rowset>`.

.. _zend.db.table.extending.insert-update:

Определение собственной логики для добавления, обновления и удаления строк
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Вы можете переопределить методы *insert()* и *update()* в своем классе
таблицы. Это дает возможность реализовать собственный код,
который исполняется до того, как будет выполнена операция с БД.
Всегда вызывайте метод родительского класса после своих
действий.

.. _zend.db.table.extending.insert-update.example:

.. rubric:: Собственная логика для управления отметками времени

.. code-block:: php
   :linenos:

   class Bugs extends Zend_Db_Table_Abstract
   {
       protected $_name = 'bugs';

       public function insert(array $data)
       {
           // добавление timestamp
           if (empty($data['created_on'])) {
               $data['created_on'] = time();
           }
           return parent::insert($data);
       }

       public function update(array $data, $where)
       {
           // добавление timestamp
           if (empty($data['updated_on'])) {
               $data['updated_on'] = time();
           }
           return parent::update($data, $where);
       }
   }


Вы можете также переопределить метод *delete()*.

.. _zend.db.table.extending.finders:

Определение собственных методов для поиска
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Вы можете реализовать собственные методы запросов в своем
классе таблицы, если приходится часто делать запросы к таблице
с одними и теми же условиями. Большинство запросов могут быть
написаны с использованием *fetchAll()*, но это требует написания
повторяющегося кода для формирования условий запроса в том
случае, если вам нужно выполнять запрос в нескольких местах
вашего приложения. Поэтому будет удобным добавить метод в
класс таблицы для выполнения часто используемых запросов к
таблице.

.. _zend.db.table.extending.finders.example:

.. rubric:: Метод для поиска ошибок с определенным статусом

.. code-block:: php
   :linenos:

   class Bugs extends Zend_Db_Table_Abstract
   {
       protected $_name = 'bugs';

       public function findByStatus($status)
       {
           $where = $this->getAdapter()->quoteInto('bug_status = ?', $status);
           return $this->fetchAll($where, 'bug_id');
       }
   }


.. _zend.db.table.extending.inflection:

Определение инфлекции в Zend_Db_Table
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Некоторые разработчики предпочитают, чтобы имя класса таблицы
сопоставлялось с именем таблицы в СУРБД с применением
преобразования, называемого **инфлекцией**.

Например, если имя вашего класса таблицы - "*BugsProducts*", то класс
должен соответствовать физической таблице в БД с названием
"*bugs_products*", если вы не произвели явное объявление свойства
класса ``$_name``. В данном преобразовании имя класса в формате
"CamelCase" должно приводиться к нижнему регистру с разделением
слов символом подчеркивания.

Вы можете указать имя таблицы БД независимо то имени класса,
объявив его в свойстве ``$_name`` во всех классах этой таблицы.

Zend_Db_Table_Abstract не производит инфлекцию при получении имени
таблицы. Если вы опустите объявление свойства ``$_name`` в своем
классе таблицы, то класс будет соответствовать таблице в БД с
точно таким же именем, как и у него.

Было бы неуместным использовать преобразование
идентификаторов из БД, поскольку это может привести к
неоднозначности или сделать некоторые идентификаторы
недоступными. Использование SQL-идентификаторов в том виде, в
котором они присутствуют в БД, делает Zend_Db_Table_Abstract проще и
гибче в использовании.

Если вы предпочитаете использовать инфлекцию, то должны
реализовать преобразование сами, переопределив метод
*_setupTableName()* в своем классе таблицы. Одним из возможных способов
является определение абстрактного класса, наследующего от
Zend_Db_Table_Abstract, и объявление классов остальных таблиц как
наследующих от этого нового класса.

.. _zend.db.table.extending.inflection.example:

.. rubric:: Пример абстрактного класса таблицы, реализующего инфлекцию

.. code-block:: php
   :linenos:

   abstract class MyAbstractTable extends Zend_Db_Table_Abstract
   {
       protected function _setupTableName()
       {
           if (!$this->_name) {
               $this->_name = myCustomInflector(get_class($this));
           }
           parent::_setupTableName();
       }
   }

   class BugsProducts extends MyAbstractTable
   {
   }


Реализация функций для произведения инфлекционного
преобразования возлагается на разработчика. Zend Framework не
предоставляет для этих целей готовых функций.



.. _`Table Data Gateway`: http://www.martinfowler.com/eaaCatalog/tableDataGateway.html
.. _`Row Data Gateway`: http://www.martinfowler.com/eaaCatalog/rowDataGateway.html
