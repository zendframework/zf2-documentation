.. _zend.feed.importing:

Импортирование лент с помощью Zend_Feed
=======================================

*Zend_Feed* позволяет легко получать ленты. Если вам известен URI
ленты, то просто используйте метод *Zend_Feed::import()*:

.. code-block:: php
   :linenos:

   $feed = Zend_Feed::import('http://feeds.example.com/feedName');


Еще вы можете использовать *Zend_Feed* для извлечения содержимого
ленты из файла или строки:

.. code-block:: php
   :linenos:

   // импортирование ленты из текстового файла
   $feedFromFile = Zend_Feed::importFile('feed.xml');

   // импортирование ленты из строки
   $feedFromPHP = Zend_Feed::importString($feedString);


В примерах выше в случае успеха возвращается объект одного из
классов, расширяющих *Zend_Feed_Abstract*, в зависимости от типа ленты.
Если посредством одного из вышеприведенных методов для
импортирования была извлечена лента RSS, то будет возвращен
объект *Zend_Feed_Rss*. Если же импортируется лента Atom, то будет
возвращен объект *Zend_Feed_Atom*. Эти методы для импортирования
будут бросать исключение *Zend_Feed_Exception* в случае ошибки, такой,
как недоступная для чтения или плохо сформированная лента.

.. _zend.feed.importing.custom:

Создание собственных лент
-------------------------

*Zend_Feed* позволяет разработчикам легко создавать собственные
ленты. Вам нужно просто создать массив и импортировать его в
Zend_Feed. Импорт из массива может быть выполнен с помощью методов
*Zend_Feed::importArray()* или *Zend_Feed::importBuilder()*. В последнем методе массив
будет сформирован на лету с помощью специального источника
данных, реализующего интерфейс *Zend_Feed_Builder_Interface*.

.. _zend.feed.importing.custom.importarray:

Импортирование массива
^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: php
   :linenos:

   // Импортирование ленты из массива
   $atomFeedFromArray = Zend_Feed::importArray($array);

   // Следующая строка эквивалентна предыдущей
   // По умолчанию возвращается экземпляр Zend_Feed_Atom
   $atomFeedFromArray = Zend_Feed::importArray($array, 'atom');

   // Импортирование ленты RSS из массива
   $rssFeedFromArray = Zend_Feed::importArray($array, 'rss');


Формат массива должен соответствовать следующей структуре:

.. code-block:: php
   :linenos:

   array(
         'title'       => 'заголовок ленты', // обязательный
         'link'        => 'канонический URL ленты', // обязательный
         'lastUpdate'  => 'время обновления', // опциональный
         'published'   => 'время публикации', // опциональный
         'charset'     => 'кодировка для текстовых данных', // обязательный
         'description' => 'краткое описание ленты', // опциональный
         'author'      => 'автор/издатель ленты', // опциональный
         'email'       => 'e-mail автора', // опциональный
         'webmaster'   =>     // опциональный, игнорируется, если используется Atom
                          'e-mail лица, отвечающего за технические вопросы'
         'copyright'   => 'авторские права', // опциональный
         'image'       => 'URL к изображению', // опциональный
         'generator'   => 'генератор', // опциональный
         'language'    => 'язык, на котором выпускается лента', // опциональный
         'ttl'         =>     // опциональный, игнорируется, если используется Atom
                          'сколько минут лента может храниться в кэше ' .
                          'до обновления',
         'rating'      =>     // опциональный, игнорируется, если используется Atom
                          'рейтинг PICS',
         'cloud'       => array(
                                'domain'            => 'домен, пример: rpc.sys.com', // обязательный
                                'port'              => 'порт', // опциональный, по умолчанию 80
                                'path'              => 'путь, пример: /RPC2', // обязательный
                                'registerProcedure' => 'процедура для вызова, пример: myCloud.rssPleaseNotify', // обязательный
                                'protocol'          => 'используемый протокол, например, soap или xml-rpc' // обязательный
                                ), // веб-сервис, поддерживающий интерфейс
                                   // rssCloud, отвечающий за уведомления об изменениях в канале
                                   // опциональный, игнорируется, если используется Atom
         'textInput'   => array(
                                'title'       => 'надпись для кнопки отправки', // обязательный
                                'description' => 'пояснение к текстовому полю', // обязательный
                                'name'        => 'атрибут name для текстового поля', // обязательный
                                'link'        => 'URL скрипта, которому будет отправлены данные' // обязательный
                                ), // текстовое поле для ввода, которое может отображаться в ленте
                                   // опциональный, игнорируется, если используется Atom
         'skipHours'   => array(
                                'часы в формате 24'
                                // может содержать до 24 элементов, значения которых должны
                                // находиться в диапазоне 0..23
                                ), // Указывает аггрегатору, в какие часы он может не обновлять канал
                                   // опциональный, игнорируется, если используется Atom
         'skipDays '   => array(
                                'пропускаемые дни недели'
                                // может содержать до 7 элементов, значениями которых должны быть
                                // Monday, Tuesday, Wednesday, Thursday, Friday, Saturday или Sunday
                                ), // Указывает аггрегатору, в какие дни недели он может не обновлять канал
                                   // опциональный, игнорируется, если используется Atom
         'itunes'      => array(
                                'author'       => 'автор', // опциональный, по умолчанию используется элемент из channel
                                'owner'        => array(
                                                        'name' => 'имя владельца', // опциональный, по умолчанию используется элемент из channel
                                                        'email' => 'e-mail владельца' // опциональный, по умолчанию используется элемент из channel
                                                        ) // владелец подкаста // опциональный
                                'image'        => 'изображение для альбома/подкаста', // опциональный, по умолчанию используется элемент из channel
                                'subtitle'     => 'краткое описание', // опциональный, по умолчанию используется элемент из channel
                                'summary'      => 'полное описание', // опциональный, по умолчанию используется элемент из channel
                                'block'        => 'блокирует показ (yes|no)', // опциональный
                                'category'     => array(
                                                        array('main' => 'основная категория', // обязательный
                                                              'sub'  => 'подкатегория' // опциональный
                                                              ),
                                                        // до 3-х элементов с парами категория/подкатегория
                                                        ) // 'категории для навигации' // обязательный
                                'explicit'     => 'индикатор наличия материалов откровенного содержания (yes|no|clean)', // опциональный
                                'keywords'     => 'список из ключевых слов, разделенных запятой (до 12 слов)', // опциональный
                                'new-feed-url' => 'используется для того, чтобы сообщить iTunes о новом URL ленты' // опциональный
                                ) // данные для iTunes // опциональный, игнорируется, если используется Atom
         'entries'     => array(
                                array(
                                      'title'        => 'заголовок сообщения', // обязательный
                                      'link'         => 'URL сообщения', // обязательный
                                      'description'  => 'краткое описание', // только текст без HTML, обязательный
                                      'guid'         => 'идентификатор сообщения, если не передан, то используется URL сообщения', // опциональный
                                      'content'      => 'содержание сообщения', // может содержать HTML, опциональный
                                      'lastUpdate'   => 'дата публикации', // опциональный
                                      'comments'     => 'страница для комментариев к сообщению', // опциональный
                                      'commentRss'   => 'URL ленты для комментариев, относящихся к сообщению', // опциональный
                                      'source'       => array(
                                                              'title' => 'заголовок оригинального источника', // обязательный
                                                              'url' => 'URL оригинального источника', // обязательный
                                                              ), // оригинальный источник сообщения // опциональный
                                      'category'     => array(
                                                              array(
                                                                    'term' => 'имя категории', // обязательный
                                                                    'scheme' => 'URL ресурса с классификацией' // опциональный
                                                                    ),
                                                              array(
                                                                    // данные второй категории и т.д.
                                                                    )
                                                              ), // список прикрепленных категорий // опциональный
                                      'enclosure'    => array(
                                                              array(
                                                                    'url' => 'URL вложения', // обязательный
                                                                    'type' => 'тип MIME вложения', // опциональный
                                                                    'length' => 'размер вложения в октетах' // опциональный
                                                                    ),
                                                              array(
                                                                    // данные для второго вложения и т.д.
                                                                    )
                                                              ) // список вложений для сообщения // опциональный
                                      ),
                                array(
                                      // данные второго сообщения и т.д.
                                      )
                                )
          );


Информационные ресурсы:

   - Спецификация RSS 2.0: `RSS 2.0`_

   - Спецификация Atom: `RFC 4287`_

   - Спецификация WFW: `Well Formed Web`_

   - Спецификация iTunes: `Технические спецификации iTunes`_



.. _zend.feed.importing.custom.importbuilder:

Импортирование из специального источника данных
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Вы можете создать экземпляр Zeed_Feed из любого источника данных,
реализующего интерфейс *Zend_Feed_Builder_Interface*. Вам нужно только
реализовать методы *getHeader()* и *getEntries()* для того, чтобы можно было
использовать свой объект с *Zend_Feed::importBuilder()*. Простой пример - вы
можете использовать компоновщик *Zend_Feed_Builder*, который принимает
массив в своем конструкторе, выполняет некоторую проверку и
затем может использоваться в методе *importBuilder()*. *getEntries()* должен
возвращать массив экземпляров *Zend_Feed_Builder_Entry*.

.. note::

   *Zend_Feed_Builder* служит только в качестве конкретной реализации
   для демонстрации использования. Пользователи должны
   создавать свои классы, реализующие интерфейс
   *Zend_Feed_Builder_Interface*.

Ниже приведен пример использования *Zend_Feed::importBuilder()*:

.. code-block:: php
   :linenos:

   // Импортирование ленты из специального созданного ресурса-компоновщика
   $atomFeedFromArray =
       Zend_Feed::importBuilder(new Zend_Feed_Builder($array));

   // Следующая строка эквивалентна предыдущей.
   // По умолчанию возвращается экземпляр Zend_Feed_Atom
   $atomFeedFromArray =
       Zend_Feed::importArray(new Zend_Feed_Builder($array), 'atom');

   // Импортирование RSS-ленты из специально созданного ресурса-компоновщика
   $rssFeedFromArray =
       Zend_Feed::importArray(new Zend_Feed_Builder($array), 'rss');


.. _zend.feed.importing.custom.dump:

Дапм содержимого ленты
^^^^^^^^^^^^^^^^^^^^^^

Для того, чтобы произвести дамп экземпляра *Zend_Feed_Abstract*, вы
можете использовать методы *send()* или *saveXml()*.

.. code-block:: php
   :linenos:


   assert($feed instanceof Zend_Feed_Abstract);

   // вывод дампа ленты
   print $feed->saveXML();

   // отправка HTTP-заголовков и вывод дампа ленты
   $feed->send();




.. _`RSS 2.0`: http://blogs.law.harvard.edu/tech/rss
.. _`RFC 4287`: http://tools.ietf.org/html/rfc4287
.. _`Well Formed Web`: http://wellformedweb.org/news/wfw_namespace_elements
.. _`Технические спецификации iTunes`: http://www.apple.com/itunes/store/podcaststechspecs.html
