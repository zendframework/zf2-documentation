.. _zend.json.objects:

Объекты JSON
============

Когда объекты PHP закодировываются в JSON, все публичные свойства
этого объекта будут закодированы в объект JSON.

JSON не поддерживает ссылки на объекты, поэтому следите за тем,
чтобы не закодировывать объекты с рекурсивными ссылками. Если
вы имеете дело с рекурсией, то в вызове методов *Zend_Json::encode()* и
*Zend_Json_Encoder::encode()* можно установить второй необязательный
параметр для проверки на рекурсию; если один и тот же объект
подвергается сериализации дважды, то будет сгенерировано
исключение.

Декодирование объектов JSON представляет собой дополнительную
сложность, так как объекты Javascript скорее соответствуют
ассоциативным массивам в PHP. Одни советуют передавать
идентификатор класса, экземпляр этого класса должен быть
создан и заполнен парами ключ/значение объекта JSON; другие
считают, что это может представлять собой серьезную угрозу
безопасности.

По умолчанию *Zend_Json* будет декодировать объекты JSON как
ассоциативные массивы. Но если вы хотите получить объект, то
можете указать это:

.. code-block:: php
   :linenos:
   <?php
   // Декодировать объект как объект
   $phpNative = Zend_Json::decode($encodedValue, Zend_Json::TYPE_OBJECT);
   ?>
Любые объекты, декодированные таким образом, возвращаются как
объекты *StdClass* со свойствами, соответствующими парам
ключ/значение в нотации JSON.

Рекомендацией Zend Framework является то, что разрабочик должен сам
принимать решение, как декодировать объект JSON. Если должен
быть создан объект определенного типа, он может быть создан в
коде разработчика и заполнен значениями, декодированными с
помощью *Zend_Json*.


