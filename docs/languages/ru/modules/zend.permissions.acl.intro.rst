.. EN-Revision: none
.. _zend.acl.introduction:

Введение
========

``Zend\Permissions\Acl`` предоставляет легковесную и гибкую реализацию списка
прав доступа (*ACL*) и управления привилегиями. Приложение может
использовать такие списки для контроля доступа одних объектов
к другим - защищенным.

В рамках данной документации,

   - **Ресурс**- объект, доступ к которому контролируется.

   - **Роль**- объект, который может запрашивать доступ к ресурсу.

Говоря проще, **роли запрашивают доступ к ресурсам**. Например,
если парковщик запрашивает доступ к автомобилю, то парковщик -
это роль, а автомобиль - ресурс, поскольку доступ к автомобилю
не может предоставляться всем без исключения.

Благодаря спецификации и использованию списка прав доступа
(ACL) приложение может контролировать предоставление ролям
доступа к ресурсам.

.. _zend.acl.introduction.resources:

Ресурсы
-------

Создать ресурс в ``Zend\Permissions\Acl`` очень просто. ``Zend\Permissions\Acl`` предоставляет
интерфейс ресурса ``Zend\Permissions\Acl\Resource\ResourceInterface`` для облегчения процесса
создания ресурса. Этот интерфейс содержит только один метод,
*getResourceId()*. Классу достаточно реализовывать этот интерфейс для
того, чтобы ``Zend\Permissions\Acl`` рассматривал объект этого класса как
ресурс. Кроме того, ``Zend\Permissions\Acl`` предоставляет *Zend\Permissions\Acl\Resource* в качестве
базового класса, который разработчики могут расширять по
желанию.

``Zend\Permissions\Acl`` предоставляет древовидную структуру, в которую могут
добавляться различные ресурсы. В этой структуре они могут быть
организованы от общих (корень дерева) к специфическим (листья
дерева). При запросах к определенным ресурсам в иерархии будет
выполнен автоматический поиск правил, относящихся к
ресурсам-предкам, учитывающий простое наследование правил.
Например, если некое общее правило должно действовать в каждом
здании города, то проще прикрепить его к городу, чем крепить к
каждому зданию в городе. Однако, для некоторых зданий могут
потребоваться исключения из этого правила, в ``Zend\Permissions\Acl`` это
достигается путем закрепления исключений за каждым зданием,
требующим исключений из правила. Ресурс может наследовать
только от одного родительского ресурса, однако сам
родительский ресурс может, в свою очередь, наследовать от
другого родительского ресурса и т.д.

``Zend\Permissions\Acl`` также поддерживает права доступа к ресурсам (например,
"создание", "чтение", "обновление", "удаление"), разработчик может
присваивать правила, которые будут влиять на все или
определенные права доступа к ресурсу.

.. _zend.acl.introduction.roles:

Роли
----

Как и в случае с ресурсами, создавать роль тоже очень просто.
Все роли должны реализовывать интерфейс ``Zend\Acl\Role\Interface``. Этот
интерфейс содержит единственный метод *getRoleId()*. Кроме того,
``Zend\Permissions\Acl`` предоставляет ``Zend\Permissions\Acl\GenericRole`` в качестве базового класса,
который разработчики могут расширять по желанию.

В ``Zend\Permissions\Acl`` роль может наследовать от одной или от нескольких
ролей. Это реализовано для поддержки наследования правил
между ролями. Например, пользовательская роль, такая как
"Салли", может принадлежать одной или нескольким родительским
ролям, таким как "редактор" и "администратор". Разработчик может
привязывать правила к "редактору" и "администратору" раздельно,
и "Салли" будет наследовать правила обоих ролей. Нет
необходимости привязывать правила непосредственно к "Салли".

Хотя множественное наследование ролей - очень полезная
возможность, она также усложняет разработку. Следующий пример
демонстрирует неопределенное условие и показывает, как ``Zend\Permissions\Acl``
решает эту проблему.

.. _zend.acl.introduction.roles.example.multiple_inheritance:

.. rubric:: Множественное наследование ролей

Следующий код определяет три базовые роли: "*guest*", "*member*" и "*admin*",
от которых будут наследовать другие роли. Далее создается
"*someUser*", он наследует от этих только что созданных трех ролей.
Порядок, в котором эти роли появляются в массиве ``$parents``, важен.
При необходимости ``Zend\Permissions\Acl`` ищет правила доступа не только для
запрашиваемых ролей (в нашем случае, "*someUser*"), но и для ролей, от
которых запрашиваемая роль унаследована (в нашем примере,
"*guest*", "*member*" и "*admin*"):

.. code-block:: php
   :linenos:
   
   use Zend\Permissions\Acl\Acl;
   use Zend\Permissions\Acl\Role\GenericRole as Role;
   use Zend\Permissions\Acl\Resource\GenericResource as Resource;
   
   $acl = new Acl();

   $acl->addRole(new Role('guest'))
       ->addRole(new Role('member'))
       ->addRole(new Role('admin'));

   $parents = array('guest', 'member', 'admin');
   $acl->addRole(new Role('someUser'), $parents);

   $acl->add(new Resource('someResource'));

   $acl->deny('guest', 'someResource');
   $acl->allow('member', 'someResource');

   echo $acl->isAllowed('someUser', 'someResource') ? 'разрешен' : 'запрещен';

Поскольку нет правил, определенных специально для роли "*someUser*"
и ресурса "*someResource*", то ``Zend\Permissions\Acl`` должен производить поиск правил,
которые могут быть определены для ролей, от которых "*someUser*"
наследуется. Сперва проверяется роль "*admin*", и обнаруживается,
что для нее не определены правила доступа. Затем проверяется
роль "*member*", и ``Zend\Permissions\Acl`` обнаруживает, что есть правило
разрешающее доступ для "*member*" к "*someResource*".

Если бы ``Zend\Permissions\Acl`` продолжил поиск правил, определенных для
родительских ролей, то обнаружил бы, что для "*guest*" запрещен
доступ к "*someResource*". Это пример показывает противоречие, так как
теперь для "*someUser*" доступ к "*someResource*" разрешен и запрещен
одновременно. Конфликт произошел по причине наследования от
нескольких ролей.

``Zend\Permissions\Acl`` решает эту неоднозначность, завершая запрос, как только
находит первое правило, которое может быть применено к
запросу. В этом случае, если роль "*member*" проверяется раньше, чем
роль "*guest*", то данный пример выведет "*разрешен*".

.. note::

   При определении нескольких родительских ролей, не забывайте,
   что последний указанный родитель будет первым в списке
   поиска правил для запроса авторизации.

.. _zend.acl.introduction.creating:

Создание списка контроля доступа (ACL)
--------------------------------------

Список контроля доступа (*ACL*) может представлять собой любое
множество физических или виртуальных объектов. В целях
демонстрации, мы создадим базовый функционал *ACL* для системы
управления содержимым (*CMS*), который будет поддерживать
нескольких уровней групп к множеству областей. Чтобы создать
новый объект *ACL*, производим инстанцирование без параметров:

.. code-block:: php
   :linenos:
   
   use Zend\Permissions\Acl\Acl;  
   $acl = new Acl();

.. note::

   До тех пор, пока разработчик не определит какое-либо правило,
   разрешающее доступ, ``Zend\Permissions\Acl`` отказывает всем ролям в доступе
   ко всем привилегиям на все ресурсы.

.. _zend.acl.introduction.role_registry:

Регистрация ролей
-----------------

*CMS* почти всегда нуждаются в иерархии доступа для определения
авторских возможностей своих пользователей. Это может быть
группа "Гость", предоставляющая ограниченный доступ для
демонстрации, группа "Сотрудник" - группа большинства
пользователей *CMS*, которые производят каждодневные операции,
группа "Редактор" - для тех кто публикует и редактирует,
архивирует и удаляет контент, и, наконец, группа
"Администратор", участники которой могут выполнять все
операции, которые доступны участникам других групп, а также
управлять закрытой информацией, пользователями,
конфигурацией адинистративной части, делать резервное
копирование данных и их экспорт. Этот набор прав доступа может
быть представлен в реестре ролей, позволяя каждой группе
наследовать привилегии родительской группы, при этом имея
индивидуальные права доступа. Права доступа могут быть
изображены в следующем виде:

.. _zend.acl.introduction.role_registry.table.example_cms_access_controls:

.. table:: Контроль за доступом для демонстрационной CMS

   +-----------------------------+-------------------------------------------------------------------------------+------------------------+
   |Название                     |Индивидуальные права                                                           |Права, унаследованные от|
   +=============================+===============================================================================+========================+
   |Гость (guest)                |Просмотр (view)                                                                |Не определено           |
   +-----------------------------+-------------------------------------------------------------------------------+------------------------+
   |Сотрудник (staff)            |Редактирование (edit), предложение на публикацию (submit), исправление (revise)|Гость                   |
   +-----------------------------+-------------------------------------------------------------------------------+------------------------+
   |Редактор (editor)            |Публикация (publish), архивирование (archive), удаление (delete)               |Сотрудник               |
   +-----------------------------+-------------------------------------------------------------------------------+------------------------+
   |Администратор (administrator)|(Обладает всеми правами)                                                       |Не определено           |
   +-----------------------------+-------------------------------------------------------------------------------+------------------------+

Для этого примера мы используем ``Zend\Permissions\Acl\GenericRole``, но можно было бы
использовать любой другой класс, реализующий интерфейс
``Zend\Acl\Role\Interface``. Эти группы могут быть добавлены в реестр ролей
следующим образом:

.. code-block:: php
   :linenos:
   
   use Zend\Permissions\Acl\Acl;
   use Zend\Permissions\Acl\Role\GenericRole as Role;

   $acl = new Acl();

   // Добавление групп в реестр ролей с использованием Zend\Permissions\Acl\Role
   // Гость не наследует управление доступом
   $roleGuest = new Role('guest');
   $acl->addRole($roleGuest);

   // Сотрудник наследует от гостя
   $acl->addRole(new Role('staff'), $roleGuest);

   /*
   Делает то же самое, что и
   $acl->addRole(new Role('staff'), 'guest');
   */

   // Редактор наследует от сотрудника
   $acl->addRole(new Role('editor'), 'staff');

   // Администатор не наследует управление доступом
   $acl->addRole(new Role('administrator'));

.. _zend.acl.introduction.defining:

Определение контроля доступа
----------------------------

Теперь, когда *ACL* содержит все необходимые роли, можно
определить правила, по которым роли будут иметь доступ к
ресурсам. Вы, должно быть, заметили, что мы не определили ни
одного отдельного ресурса для этого примера, это упрощает
демонстрацию того, что правила применяются ко всем ресурсам.
``Zend\Permissions\Acl`` предоставляет реализацию, посредством которой правила
должны передаваться от общих к специфическим, минимизируя
таким образом количество необходимых правил, так как ресурсы и
роли наследуют правила, которые определены для их предков.

В результате мы можем определить умеренно сложный набор
правил минимальным кодом. Чтобы определить базовые права
доступа, описанные выше:

.. code-block:: php
   :linenos:
   <?php
   
   use Zend\Permissions\Acl\Acl;
   use Zend\Permissions\Acl\Role\GenericRole as Role;
   
   $acl = new Acl();
    
   $roleGuest = new Role('guest');
   $acl->addRole($roleGuest);
   $acl->addRole(new Role('staff'), $roleGuest);
   $acl->addRole(new Role('editor'), 'staff');
   $acl->addRole(new Role('administrator'));

   // Гость может только просматривать контент
   $acl->allow($roleGuest, null, 'view');

   /* другим способом, предыдущий блок кода может быть записан в таком виде:
   $acl->allow('guest', null, 'view');
   //*/

   // Сотрудник наследует привилегии просмотра у Гостя, но также нуждается в дополнительных привилегиях
   $acl->allow('staff', null, array('edit', 'submit', 'revise'));

   // Редактор наследует привилегии просмотра, редактирования, отправки и исправлений у Посетителя
   // но также нуждается в дополнительных привилегиях
   $acl->allow('editor', null, array('publish', 'archive', 'delete'));

   // Администратор не наследует ничего, но обладает всеми привилегиями
   $acl->allow('administrator');
Значение ``NULL`` в вызовах *allow()* в этом примере используется для
указания того, что правила, предоставляющие доступ,
действительны для всех ресурсов.

.. _zend.acl.introduction.querying:

Запросы к ACL
-------------

Теперь у нас есть гибкий *ACL*, который может использоваться для
определения того, достаточно ли прав имеет запрашивающий,
чтобы производить действия в веб-приложении. Используя метод
*isAllowed()*, производить запросы довольно просто:

.. code-block:: php
   :linenos:

   echo $acl->isAllowed('guest', null, 'view') ?
        "разрешен" : "запрещен";
   // разрешен

   echo $acl->isAllowed('staff', null, 'publish') ?
        "разрешен" : "запрещен";
   // запрещен

   echo $acl->isAllowed('staff', null, 'revise') ?
        "разрешен" : "запрещен";
   // разрешен

   echo $acl->isAllowed('editor', null, 'view') ?
        "разрешен" : "запрещен";
   // разрешен потому, что редактор наследует от гостя

   echo $acl->isAllowed('editor', null, 'update') ?
        "разрешен" : "запрещен";
   // запрещен потому, что нет правила, разрешающего обновление (update)

   echo $acl->isAllowed('administrator', null, 'view') ?
        "разрешен" : "запрещен";
   // разрешен потому, что администратор обладает всеми привилегиями

   echo $acl->isAllowed('administrator') ?
        "разрешен" : "запрещен";
   // разрешен потому, что администратор обладает всеми привилегиями

   echo $acl->isAllowed('administrator', null, 'update') ?
        "разрешен" : "запрещен";
   // разрешен потому, что администратор обладает всеми привилегиями


