.. _zend.view.introduction:

Введение
========

``Zend_View`` является классом для работы с частью вид (view) паттерна
модель-вид-контроллер (model-view-controller). То есть он предназначен
для того, чтобы помочь отделить скрипты видов от скриптов
моделей и контроллеров. Он предоставляет систему помощников,
фильтрации вывода и экранирования переменных.

``Zend_View`` не зависит от выбранной вами системы шаблонов - вы
можете использовать PHP в качестве языка шаблонов или создавать
экземпляры других систем шаблонов и работать с ними в ваших
скриптах вида.

По существу применение ``Zend_View`` состоит из двух шагов: 1. Ваш
скрипт контроллера создает экземпляр ``Zend_View`` и объявляет
переменные этого экземпляра. 2. Контроллер приказывает ``Zend_View``
воспроизвести данный вид, посредством этого производится
контроль за скриптом вида, который генерирует выходные данные
вида.

.. _zend.view.introduction.controller:

Скрипт контроллера
------------------

В качестве простого примера предположим, что ваш контроллер
имеет список данных по книгам, который нужно воспроизвести
через вид. Скрипт контроллера может выглядеть наподобие этого:

.. code-block:: php
   :linenos:

   // использование модели для получения данных о заголовках и авторах книг
   $data = array(
       array(
           'author' => 'Hernando de Soto',
           'title' => 'The Mystery of Capitalism'
       ),
       array(
           'author' => 'Henry Hazlitt',
           'title' => 'Economics in One Lesson'
       ),
       array(
           'author' => 'Milton Friedman',
           'title' => 'Free to Choose'
       )
   );

   // теперь присваиваем данные по книгам экземпляру Zend_View
   Zend_Loader::loadClass('Zend_View');
   $view = new Zend_View();
   $view->books = $data;

   // и выполняем скрипт вида "booklist.php"
   echo $view->render('booklist.php');

.. _zend.view.introduction.view:

Скрипт вида
-----------

Теперь нам нужен сопутствующий скрипт вида "booklist.php". Это такой
же скрипт PHP, как и остальные, за одним исключением: он
выполняется в области видимости экземпляра ``Zend_View``, это
означает, что ``$this`` ссылается на экземпляр ``Zend_View``. Переменные,
присваиваемые в контроллере для скрипта вида, являются
открытыми свойствами экземпляра ``Zend_View``. Таким образом,
базовый скрипт вида может выглядеть следующим образом:

.. code-block:: php
   :linenos:

   <?php if ($this->books): ?>

       <!-- Таблица из нескольких книг. -->
       <table>
           <tr>
               <th>Author</th>
               <th>Title</th>
           </tr>

           <?php foreach ($this->books as $key => $val): ?>
           <tr>
               <td><?php echo $this->escape($val['author']) ?></td>
               <td><?php echo $this->escape($val['title']) ?></td>
           </tr>
           <?php endforeach; ?>

       </table>

   <?php else: ?>

       <p>Нет книг для отображения.</p>

   <?php endif; ?>

Обратите внимание, что мы используем метод *escape()* для
экранирования переменных.

.. _zend.view.introduction.options:

Опции
-----

``Zend_View`` имеет несколько опций, которые могут использоваться
для управления поведением ваших скриптов вида:

- *basePath*- базовый путь, начиная от которого устанавливаются пути
  скриптов, помощников и фильтров. Предполагается, что
  используется следующая структура директорий:

  .. code-block:: php
     :linenos:

     base/path/
         helpers/
         filters/
         scripts/

  Эта опция может быть установлена через методы *setBasePath()*,
  *addBasePath()* или опцию *basePath* для конструктора.

- *encoding*- кодировка, которую следует использовать при вызове
  функций *htmlentities()*, *htmlspecialchars()* и др. По умолчанию используется
  ISO-8859-1 (latin1). Может быть установлена через метод *setEncoding()* или
  опцию *encoding* для конструктора.

- *escape*- обратный вызов, который следует использовать для метода
  *escape()*. Может быть установлен через метод *setEscape()* или опцию
  *escape* для конструктора.

- *filter*- фильтр, который следует использовать после рендеринга
  скрипта вида. Может быть установлен через методы *setFilter()*,
  *addFilter()*, или опцию *filter* для конструктора.

- *strictVars*- если опция установлена, то ``Zend_View`` генерирует
  уведомления (notices) и предупреждения (warnings), когда производится
  обращение к неинициализированной переменной. Опция может
  быть установлена посредством вызова *strictVars(true)* или передачи
  опции *strictVars* конструктору.

.. _zend.view.introduction.shortTags:

Короткие теги в скриптах вида
-----------------------------

В нашей документации и примерах мы применяем короткие теги PHP:
*<?* and *<?=*. Кроме того, мы обычно используем `альтернативный
синтаксис для управляющих структур`_. Их удобно использовать
при написании скриптов вида, они делают конструкции более
лаконичными и позволяют размещать операторы без лишних
переходов на другую строку.

Несмотря на это, многие разработчики предпочитают
использовать длинную форму записи для обеспечения валидности
или переносимости кода. Например, в рекомендуемой
конфигурации PHP (файл php.ini.recommended) опция *short_open_tag* отключена.
Также, если вы используете XML в своих скриптах вида, то с
короткими открывающими тегами PHP они не будут проходить
валидацию.

Кроме того, если вы используете короткие теги, и опция *short_open_tag*
отключена, то скрипты вида будут либо приводить к ошибкам
выполнения, либо просто выводить пользователю код, включенный
в эти теги.

В последнем случае, если вы хотите использовать короткие теги,
но они отключены, у вас есть два возможных решения:

- Включить короткие теги в своем файле *.htaccess*:

  .. code-block:: apache
     :linenos:

     php_value "short_open_tag" "on"

  Это будет действовать только в том случае, если у вас есть
  права на создание и использование файлов *.htaccess*. Эта
  директива также может быть добавлена в конфигурационный файл
  *httpd.conf*.

- Включить обертку потока (stream wrapper), которая будет на лету
  преобразовывать короткие теги в полные:

  .. code-block:: php
     :linenos:

     $view->setUseStreamWrapper(true);

  В этом вызове ``Zend_View_Stream`` регистрируется в качестве обертки
  потока к скриптам вида, благодаря этому код будет работать
  так же, как если бы короткие теги были были включены.

.. note::

   **Обертка потока для скриптов вида снижает производительность**

   Использование обертки потока **снижает** производительность
   вашего приложения. Мы рекомендуем включать короткие теги,
   переписывать свои скрипты вида с тем, чтобы использовалась
   полная форма записи тегов, либо использовать продуманную
   стратегию частичного или полного кэширования содержимого
   страниц.

.. _zend.view.introduction.accessors:

Вспомогательные аксессоры
-------------------------

Скорее всего, вам никогда не понадобится вызывать *assign()*, *render()*
и другие перечисленные ниже методы для установки/добавления
фильтров, помощников, путей к скриптам вида. Тем не менее, если
требуется расширить класс ``Zend_View`` или нужен доступ к его
внутреннему коду, то можно использовать следующие аксессоры:

- *getVars()* возвращает все установленные переменные.

- *clearVars()* удаляет все присвоенные переменные, полезен, если вы
  хотите повторно использовать объект вида, но хотите
  контролировать доступность переменных.

- *getScriptPath($script)* возвращает вычисленный путь к данному скрипту
  вида.

- *getScriptPaths()* возвращает все зарегистрированные пути к скриптам
  вида.

- *getHelperPath($helper)* возвращает вычисленный путь к классу помощника,
  имя которого передается в качестве параметра.

- *getHelperPaths()* возвращает все зарегистрированные пути к классам
  помощников.

- *getFilterPath($filter)* возвращает вычисленный путь к классу фильтра,
  имя которого передается в качестве параметра.

- *getFilterPaths()* возвращает все зарегистрированные пути к классам
  фильтров.



.. _`альтернативный синтаксис для управляющих структур`: http://us.php.net/manual/en/control-structures.alternative-syntax.php
