.. _zend.db.statement:

Zend_Db_Statement
=================

В дополнение к удобным методам, таким, как *fetchAll()* и *insert()*,
документированным в :ref:` <zend.db.adapter>`, вы можете использовать
объект оператора для того, чтобы восспользоваться бOльшим
количеством опций запуска запросов и получения результатов
запроса. Этот раздел описывает, как получить экземпляр объекта
оператора и как использовать его методы.

Zend_Db_Statement основан на объекте PDOStatement в расширении `PDO`_.

.. _zend.db.statement.creating:

Создание оператора
------------------

Обычно объект оператора возвращается методом *query()* класса
адаптера БД. Этот метод является основным средством
подготовки любых операторов SQL. Первым аргументом является
строка, содержащая оператор SQL. Опциональный второй аргумент -
массив значений для подстановки вместо меток заполнения в
строке SQL.

.. _zend.db.statement.creating.example1:

.. rubric:: Создание объекта оператора SQL с помощью query()

.. code-block:: php
   :linenos:

   $stmt = $db->query(
               'SELECT * FROM bugs WHERE reported_by = ? AND bug_status = ?',
               array('goofy', 'FIXED')
           );


Объект оператора соответствует оператору SQL, который был
подготовлен и выполнен с заданными значениями для связки. Если
оператор был запросом SELECT или любым другим типом оператора,
который возвращает результат, то он уже готов для извлечения
результатов.

Вы можете создать оператор с помощью его конструктора, но это
менее типичный вариант использования. Не существует
метода-фабрики для создания этого объекта, поэтому нужно
загружать определенный класс оператора и вызывать его
конструктор. Передавайте объект адаптера в качестве первого
аргумента и строку, содержащую оператор SQL в качестве второго.
Теперь оператор подготовлен, но еще не выполнен.

.. _zend.db.statement.creating.example2:

.. rubric:: Using a SQL statement constructor

.. code-block:: php
   :linenos:

   $sql = 'SELECT * FROM bugs WHERE reported_by = ? AND bug_status = ?';

   $stmt = new Zend_Db_Statement_Mysqli($db, $sql);


.. _zend.db.statement.executing:

Выполнение оператора
--------------------

Вам нужно выполнять оператор самостоятельно, если создали его
объект с помощью его конструктора или хотите запустить один и
тот же оператор несколько раз. Используйте метод *execute()*
объекта оператора. Его единственным аргументом является
массив значений для связки с метками заполнения в операторе.

Если вы используете **позиционные параметры**- те, которые
помечаются знаками вопроса (*?*), - то передавайте значения для
связки в простом массиве.

.. _zend.db.statement.executing.example1:

.. rubric:: Выполнение оператора с позиционными параметрами

.. code-block:: php
   :linenos:

   $sql = 'SELECT * FROM bugs WHERE reported_by = ? AND bug_status = ?';

   $stmt = new Zend_Db_Statement_Mysqli($db, $sql);

   $stmt->execute(array('goofy', 'FIXED'));


Если вы используете **именованные параметры**- те, что
указываются через строковой идентификатор с двоеточием (*:*) в
начале, - то передавайте значения для связки в ассоциативном
массиве. Ключи этого массива должны соответствовать именам
параметров.

.. _zend.db.statement.executing.example2:

.. rubric:: Выполнение оператора с именованными параметрами

.. code-block:: php
   :linenos:

   $sql = 'SELECT * FROM bugs WHERE ' .
          'reported_by = :reporter AND bug_status = :status';

   $stmt = new Zend_Db_Statement_Mysqli($db, $sql);

   $stmt->execute(array(':reporter' => 'goofy', ':status' => 'FIXED'));


Операторы PDO поддерживают как позиционные, так именованные
параметры по отдельности, но не вместе в одном операторе SQL.
Некоторые классы Zend_Db_Statement для не-PDO расширений могут
поддерживать только один тип параметров.

.. _zend.db.statement.fetching:

Извлечение результатов выполнения оператора SELECT
--------------------------------------------------

Вы можете вызывать методы объекта оператора для получения
строк из SQL-операторов, которые возвращают наборы результатов.
SELECT, SHOW, DESCRIBE и EXPLAIN являются примерами операторов, которые
генерируют наборы результатов, а INSERT, UPDATE и DELETE - примерами
операторов, которые не возвращают наборы результатов. Вы
можете выполнять последние операторы, используя Zend_Db_Statement, но
не можете вызывать методы для получения строк из результатов
их выполнения.

.. _zend.db.statement.fetching.fetch:

Извлечение одной строки из набора результатов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Для извлечения одной строки из набора результатов используйте
метод *fetch()* объекта оператора. Все три аргумента этого метода
являются опциональными:

- **Формат извлечения**- первый аргумент. Он используется для
  управления структурой, в которой возвращаются данные.
  Описания допустимых значений и соответствующих им форматов
  данных читайте в :ref:` <zend.db.adapter.select.fetch-mode>`.

- **Ориентация курсора**- второй аргумент. Значением по
  умолчанию является константа Zend_Db::FETCH_ORI_NEXT, которая просто
  означает, что каждый вызов метода *fetch()* возвращает следующую
  строку в наборе результатов, в той же последовательности, в
  которой строки были возвращены из БД.

- **Смещение**- третий аргумент. Если ориентация курсора -
  Zend_Db::FETCH_ORI_ABS, то число смещения - порядковый номер строки для
  возвращения. Если ориентация курсора - Zend_Db::FETCH_ORI_REL, то число
  смещения является относительным по отношению к положению
  курсора до того, как был вызван *fetch()*.

*fetch()* возвращает ``FALSE``, если все строки из набора результатов
были извлечены.

.. _zend.db.statement.fetching.fetch.example:

.. rubric:: Использование fetch() в цикле

.. code-block:: php
   :linenos:

   $stmt = $db->query('SELECT * FROM bugs');

   while ($row = $stmt->fetch()) {
       echo $row['bug_description'];
   }


См. также `PDOStatement::fetch()`_.

.. _zend.db.statement.fetching.fetchall:

Извлечение всего набора результатов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Для единовременного получения всех строк из набора
результатов используйте метод *fetchAll()*. Он является
эквивалентным вызову метода *fetch()* в цикле и возвращению всех
строк в массиве. Метод *fetchAll()* принимает два аргумента. Первый
из них - формат извлечения, описанный выше, через второй
аргумент указывается число возвращаемых столбцов, если формат
извлечения Zend_Db::FETCH_COLUMN.

.. _zend.db.statement.fetching.fetchall.example:

.. rubric:: Использование fetchAll()

.. code-block:: php
   :linenos:

   $stmt = $db->query('SELECT * FROM bugs');

   $rows = $stmt->fetchAll();

   echo $rows[0]['bug_description'];


См. также `PDOStatement::fetchAll()`_.

.. _zend.db.statement.fetching.fetch-mode:

Изменение формата извлечения
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

По умолчанию объект оператора возвращает строки из набора
результатов в виде ассоциативного массива имен столбцов и их
значений. Вы можете указать другой формат для класса
оператора, так же, как это делается для класса адаптера. Вы
можете использовать метод *setFetchMode()* объекта оператора для
указания режима извлечения. Указывайте режим извлечения,
используя константы FETCH_ASSOC, FETCH_NUM, FETCH_BOTH, FETCH_COLUMN и FETCH_OBJ класса
Zend_Db. Более подробную информацию об этих режимах читайте в :ref:`
<zend.db.adapter.select.fetch-mode>`. В последующих вызовах методов *fetch()* и
*fetchAll()* объекта оператора будет использоваться заданный вами
режим извлечения.

.. _zend.db.statement.fetching.fetch-mode.example:

.. rubric:: Установка формата извлечения

.. code-block:: php
   :linenos:

   $stmt = $db->query('SELECT * FROM bugs');

   $stmt->setFetchMode(Zend_Db::FETCH_NUM);

   $rows = $stmt->fetchAll();

   echo $rows[0][0];


См. также `PDOStatement::setFetchMode()`_.

.. _zend.db.statement.fetching.fetchcolumn:

Извлечение одного столбца из набора результатов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Для извлечения одного столбца из следующей строки в наборе
результатов используйте *fetchColumn()*. Опциональный аргумент -
целочисленный индекс столбца, по умолчанию это 0. Этот метод
возвращает скалярное значение или ``FALSE``, если все строки
набора результатов были уже извлечены

Обратите внимание, что этот метод работает иначе, чем метод
*fetchCol()* класса адаптера. Метод *fetchColumn()* оператора возвращает
единственное значение из одной строки. Метод *fetchCol()* адаптера
возвращает массив значений, взятых из первого столбца всех
строк набора результатов.

.. _zend.db.statement.fetching.fetchcolumn.example:

.. rubric:: Использование fetchColumn()

.. code-block:: php
   :linenos:

   $stmt = $db->query('SELECT bug_id, bug_description, bug_status FROM bugs');

   $bug_status = $stmt->fetchColumn(2);


См. также `PDOStatement::fetchColumn()`_.

.. _zend.db.statement.fetching.fetchobject:

Извлечение строки в виде объекта
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Для извлечения строки из набора результатов в виде объекта
используйте метод *fetchObject()*. Этот метод принимает два
опциональных аргумента. Первый аргумент является именем
класса для возвращаемого объекта, по умолчанию это 'stdClass'.
Второй аргумент является массивом значений, которые будут
переданы конструктору этого класса.

.. _zend.db.statement.fetching.fetchobject.example:

.. rubric:: Использование fetchObject()

.. code-block:: php
   :linenos:

   $stmt = $db->query('SELECT bug_id, bug_description, bug_status FROM bugs');

   $obj = $stmt->fetchObject();

   echo $obj->bug_description;


См. также `PDOStatement::fetchObject()`_.



.. _`PDO`: http://www.php.net/pdo
.. _`PDOStatement::fetch()`: http://www.php.net/PDOStatement-fetch
.. _`PDOStatement::fetchAll()`: http://www.php.net/PDOStatement-fetchAll
.. _`PDOStatement::setFetchMode()`: http://www.php.net/PDOStatement-setFetchMode
.. _`PDOStatement::fetchColumn()`: http://www.php.net/PDOStatement-fetchColumn
.. _`PDOStatement::fetchObject()`: http://www.php.net/PDOStatement-fetchObject
