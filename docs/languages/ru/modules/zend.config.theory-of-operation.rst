.. _zend.config.theory_of_operation:

Теоретические основы работы с Zend_Config
=========================================

Конфигурационные данные передаются конструктору ``Zend_Config`` в
виде ассоциативного массива, который может быть многомерным,
что дает возможность организовывать данные от общего к
частному. Классы адаптеров преобразуют конфигурационные
данные из хранилища в ассоциативный массив для конструктора
``Zend_Config``. Можно также передавать массивы непосредственно
конструктору ``Zend_Config`` без использования класса адаптера, т.к.
это может быть наиболее подходящим решением в некоторых
ситуациях.

Каждое значение массива конфигурационных значений становится
свойством объекта ``Zend_Config``. Ключ массива используется как имя
свойства. Если значение само является массивом, то
соответствующее свойство создается как объект ``Zend_Config``,
который заполняется данными этого массива. Это производится
рекурсивно, т.о., иерархия конфигурационных данных может иметь
любой уровень вложенности.

``Zend_Config`` реализует интерфейсы **Countable** и **Iterator** для того, чтобы
обеспечить простой доступ к конфигурационным данным. Поэтому
с объектами ``Zend_Config`` можно использовать функцию `count()`_ и такие
конструкции языка *PHP*, как `foreach`_.

По умолчанию через ``Zend_Config`` конфигурационные данные доступны
только для чтения, и операция присваивания (например,
``$config->database->host = 'example.com'``) вызовет исключение. Тем не менее, это
поведение может быть отменено при вызове конструктора, и тогда
можно будет изменять конфигурационные данные. Если
модификации разрешены, то ``Zend_Config`` также поддерживает
уничтожение значений (т.е. ``unset($config->database->host)``). Метод ``readOnly()``
может использоваться для определения того, был ли разрешены
модификации в данном объекте ``Zend_Config``. Метод ``setReadOnly()``
запрещает все дальнейшие изменения в объекте ``Zend_Config``, который
был создан с разрешением изменений.

.. note::

   Важно не путать изменение данных в памяти с сохранением
   конфигурационных данных на физическом носителе данных.
   Создание и изменение конфигурационных данных на различных
   носителях данных не входит в сферу назначений ``Zend_Config``. Для
   создания и изменения конфигурационных данных на различных
   носителях информации можно использовать сторонние
   разработки с открытым исходным кодом.

Классы адаптеров наследуют от класса ``Zend_Config``, и,
следовательно, имеют тот же функционал.

Семейство классов ``Zend_Config`` позволяет организовывать
конфигурационные данные, разбивая их на разделы. В объекты
адаптеров ``Zend_Config`` можно загружать один определенный раздел,
несколько разделов или все разделы данных (если не указан
раздел).

Классы адаптеров ``Zend_Config`` поддерживают единую модель
наследования, которая позволяет одному разделу наследовать
конфигурационные данные из другого. Это сделано для того,
чтобы уменьшить или устранить необходимость дублирования
конфигурационных данных разного назначения. Наследующий
раздел может замещать данные, унаследованные от родительского
раздела. Как и при наследовании классов PHP, раздел может
наследовать от родительского раздела, который в свою очередь
наследует от другого и т.д., но множественное наследование (т.е.
раздел C наследует напрямую от разделов A и B) не поддерживается.

Если вы имеете два объекта ``Zend_Config``, то можете объединить их в
один, используя функцию ``merge()``. Например, имея ``$config`` и ``$localConfig``
вы можете объединить данные из ``$localConfig`` с данными из ``$config``,
используя ``$config->merge($localConfig)``. Элементы из ``$localConfig`` при
совпадении имен заменят собой элементы ``$config``.

.. note::

   Объект ``Zend_Config``, который выполняет объединение, должен быть
   создан с разрешением модификаций путем передачи ``TRUE`` в
   качестве второго параметра конструктора. После того, как
   объединение будет завершено, можно использовать метод
   ``setReadOnly()`` для предотвращения всех дальнейших изменений.



.. _`count()`: http://php.net/count
.. _`foreach`: http://php.net/foreach
