.. _zend.feed.consuming-rss:

Работа с лентой RSS
===================

Чтение ленты такое же простое, как создание объекта *Zend_Feed_Rss* с
URI ленты:

.. code-block:: php
   :linenos:

   $channel = new Zend_Feed_Rss('http://rss.example.com/channelName');


Если при извлечении ленты произошла ошибка, то будет
сгенерировано исключение *Zend_Feed_Exception*.

Создав объект ленты, вы можете получить доступ к любым
стандартным свойствам канала RSS (channel) непосредственно в
объекте:

.. code-block:: php
   :linenos:

   echo $channel->title();


Обратите внимание на синтаксис функции. *Zend_Feed* использует
соглашение об интерпретации свойств как объекта XML, если они
запрошены в синтаксисе получения переменной (``$obj->property`` и как
строки, если они запрошены в синтаксисе метода (``$obj->property()``).
Это позволяет получить доступ к полному тексту любого
отдельного узла, что одновременно дает полный доступ и ко всем
дочерним элементам.

Если свойства канала имеют атрибуты, то к ним можно получить
доступ, используя синтаксис массива PHP:

.. code-block:: php
   :linenos:

   echo $channel->category['domain'];


Поскольку атрибуты не могут иметь дочерние элементы, то нет
необходимости в синтаксисе метода для получения значений
атрибутов.

Скорее всего, вам потребуется произвести обход ленты и
выполнить какие-либо операции с ее сообщениями. *Zend_Feed_Abstract*
реализует интерфейс PHP *Iterator*, поэтому вывод заголовков всех
статей в канале будет выглядеть следующим образом:

.. code-block:: php
   :linenos:

   foreach ($channel as $item) {
       echo $item->title() . "\n";
   }


На тот случай, если вы не знакомы с RSS, здесь приведены
стандартные элементы, которые должны присутствовать в канале
(элемент *<channel>*) и отдельных сообщениях RSS (элемент *<item>*).

Обязательные элементы канала:



   - *title*- имя канала

   - *link*- URL веб-сайта, соответствующего каналу

   - *description*- одно или несколько предложений, составляющих
     описание канала



Обычно используемые необязательные элементы канала:



   - *pubDate*- дата публикации канала в формате RFC 822

   - *language*- язык, на котором написано содержимое канала

   - *category*- одна или несколько (задается несколькими тегами)
     категорий, к которым принадлежит канал



Элементы *<item>* не имеют обязательных вложенных элементов. Тем
не менее, должны быть представлены заголовок *<title>* или
описание *<description>*.

Обычно используемые элементы сообщения:



   - *title*- заголовок сообщения

   - *link*- URL сообщения

   - *description*- краткое описание

   - *author*- e-mail автора

   - *category*- одна или несколько категорий, к которым принадлежит
     сообщение

   - *comments*- URL комментариев к данному сообщению

   - *pubDate*- дата публикации в формате RFC 822



В своем коде вы можете проверить, имеет ли элемент непустое
значение, следующим образом:

.. code-block:: php
   :linenos:

   if ($item->propname()) {
       // ... обработка
   }


Если вместо этого использовать ``$item->propname``, то всегда будете
получать объект. Пустой объект расценивается как ``TRUE``, поэтому
такая проверка будет некорректной.

Для получения более подробной информации читайте официальное
описание спецификации RSS 2.0: `http://blogs.law.harvard.edu/tech/rss`_



.. _`http://blogs.law.harvard.edu/tech/rss`: http://blogs.law.harvard.edu/tech/rss
