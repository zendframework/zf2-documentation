.. _zend.layout.advanced:

Использование Zend_Layout для опытных разработчиков
===================================================

Имеются различные варианты использования *Zend_Layout* для опытных
разработчиков, которые хотят адаптировать его для других
реализаций вида, другой файловой структуры и т.д.

Основные возможности расширения:

- **Собственные объекты вида.** *Zend_Layout* позволяет использовать
  любые классы, реализущие интерфейс *Zend_View_Interface*.

- **Собственные плагины фронт-контроллера.** *Zend_Layout*
  поставляется со стандартным плагином фронт-контроллера,
  который автоматизирует рендеринг макетов, производимый до
  возвращения ответа. Вы можете заменить его на собственный
  плагин.

- **Собственные помощники действий.** *Zend_Layout* поставляется со
  стандартным помощником действий, который должен подходить
  для большинства нужд, т.к. он является простым посредником к
  объекту макета.

- **Собственное определение пути к скрипту макета**. *Zend_Layout*
  позволяет использовать собственный вариант :ref:`инфлекции
  <zend.filter.inflector>` для определения пути к скрипту макета или
  просто изменить прикрепленный инфлектор для указания
  собственных правил инфлекции.

.. _zend.layout.advanced.view:

Собственные объекты вида
------------------------

*Zend_Layout* позволяет использовать любые классы, реализующие
интерфейс *Zend_View_Interface* или наследующие от *Zend_View_Abstract* для
рендеринга скриптов макета. Просто передайте свой объект вида
в качестве параметра конструктору/*startMvc()* или установите его,
используя аксессор *setView()*:

.. code-block:: php
   :linenos:
   <?php
   $view = new My_Custom_View();
   $layout->setView($view);
   ?>
.. note::

   **Не все реализации Zend_View одинаковы**

   Хотя *Zend_Layout* позволяет использовать любые классы,
   реализующие *Zend_View_Interface*, вы можете столкнуться с проблемами,
   если они не используют помощники *Zend_View*-а, в частности,
   помощников макета и :ref:`меток заполнения
   <zend.view.helpers.initial.placeholder>`. Это потому, что *Zend_Layout* делает набор
   переменных в объекте доступным через себя или через :ref:`метки
   заполнения <zend.view.helpers.initial.placeholder>`.

   Если требуется использовать свою реализацию *Zend_View*, которая
   не поддерживает этих помощников, то нужно найти способ для
   получения переменных внутри вида. Это может быть реализовано
   путем расширения объекта *Zend_Layout* и изменения метода *render()*
   для передачи переменных виду, либо путем создания своего
   собственного класса плагина, который передает их до
   рендеринга макета.

   Также если ваша реализация вида поддерживает возможность
   использования плагинов, то вы можете обращаться к переменным
   через метку заполнения 'Zend_Layout', используя :ref:`помощника меток
   заполнения <zend.view.helpers.initial.placeholder>`:

   .. code-block:: php
      :linenos:
      <?php
      $placeholders = new Zend_View_Helper_Placeholder();
      $layoutVars   = $placeholders->placeholder('Zend_Layout')->getArrayCopy();
      ?>
.. _zend.layout.advanced.plugin:

Собственные плагины фронт-контроллера
-------------------------------------

Если используются компоненты MVC, *Zend_Layout* регистрирует плагин
фронт-контроллера, который производит рендеринг макета до
того, как будет произведен выход из цикла диспетчеризации. Для
большинства случаев подходит плагин по умолчанию, но если вы
хотите написать собственный, то можете указать имя класса
плагина для загрузки путем передачи опции *pluginClass* методу
*startMvc()*.

Плагин, написанный вами для этой цели, должен наследовать от
класса *Zend_Controller_Plugin_Abstract* и принимать объект макета в качестве
аргумент конструктора. Иначе вы должны продумать детали своей
реализации плагина.

По умолчанию используется плагин *Zend_Layout_Controller_Plugin_Layout*.

.. _zend.layout.advanced.helper:

Собственные помощники действий
------------------------------

При использовании с компонентами MVC *Zend_Layout* регистрирует
помощника действий с помощью брокера помощников. Используемый
по умолчанию *Zend_Layout_Controller_Action_Helper_Layout* действует как простой
посредник к объекту макета и должен подходить в большинстве
случаев.

Если понадобится написать дополнительный функционал, то
просто напишите класс помощника действий, наследующий от
*Zend_Controller_Action_Helper_Abstract*, и передайте его имя в качестве опции
*helperClass* методу *startMvc()*.

.. _zend.layout.advanced.inflector:

Собственное определение пути к скрипту макета: использование инфлектора
-----------------------------------------------------------------------

*Zend_Layout* использует *Zend_Filter_Inflector* для установки цепочки
фильтров, преобразующей имя макета в путь к скрипту макета. По
умолчанию он использует правила 'CamelCaseToDash', 'StringToLower' и суффикс
'phtml' для преобразования имени макета в путь. Например:

- 'foo' будет преобразован в 'foo.phtml'.

- 'FooBarBaz' будет преобразован в 'foo-bar-baz.phtml'.

Есть три способа изменить инфлекцию - модификация шаблона
инфлекции и/или суффикса скрипта вида через аксессоры *Zend_Layout*,
изменение правил инфлекции и шаблона, связанных с экземпляром
*Zend_Layout* инфлектора, создание своего собственного экземпляра
инфлектора и передача его *Zend_Layout::setInflector()*.

.. _zend.layout.advanced.inflector.accessors:

.. rubric:: Использование аксессоров Zend_Layout для модификации инфлектора

Используемый по умолчанию инфлектор *Zend_Layout* использует
статические ссылки для цели и суффикса скрипта вида, и имеет
аксессоры для установки этих значений.

.. code-block:: php
   :linenos:
   <?php
   // Установка шаблона:
   $layout->setInflectorTarget('layouts/:script.:suffix');

   // Установка суффикса скрипта макета:
   $layout->setViewSuffix('php');
   ?>
.. _zend.layout.advanced.inflector.directmodification:

.. rubric:: Непосредственное изменение инфлектора Zend_Layout

Инфлекторы имеют шаблон и одно или более правил. По умолчанию с
*Zend_Layout* используется шаблон ':script.:suffix'; ':script' передает
зарегистрированное имя макета, в то же время как ':suffix' является
статическим правилом для инфлектора.

Предположим, вы хотите, чтобы скрипт макета заканчивался
суффиксом 'html', и что вы хотите разделить исходные слова в
формате CamelCased символами подчеркивания всесто тире и не
приводить их к нижнему регистру. Кроме этого, вы хотите искать
скрипт в поддиректории 'layouts'.

.. code-block:: php
   :linenos:
   <?php
   $layout->getInflector()->setTarget('layouts/:script.:suffix')
                          ->setStaticRule('suffix', 'html')
                          ->setFilterRule(array('CamelCaseToUnderscore'));
   ?>
.. _zend.layout.advanced.inflector.custom:

.. rubric:: Собственные инфлекторы

В большинстве случаев модификации существующего инфлектора
будет достаточно. Тем не менее, у вас может быть инфлектор,
который вы хотите использовать в разных местах и с объектами
различных типов. *Zend_Layout* поддерживает это.

.. code-block:: php
   :linenos:
   <?php
   $inflector = new Zend_Filter_Inflector('layouts/:script.:suffix');
   $inflector->addRules(array(
       ':script' => array('CamelCaseToUnderscore'),
       'suffix'  => 'html'
   ));
   $layout->setInflector($inflector);
   ?>
.. note::

   **Инфлекция может быть отключена**

   Инфлекция может быть отключена или включена с
   использованием аксессоров объекта *Zend_Layout*. Это может быть
   полезным, если вы хотите указывать абсолютный путь к скрипту
   макета или знаете, что механизм, который вы будете
   использовать для указания скрипта макета, не требует
   инфлекции. Используйте методы *enableInflection()* и *disableInflection()*.


