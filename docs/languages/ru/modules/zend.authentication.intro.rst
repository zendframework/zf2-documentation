.. EN-Revision: none
.. _zend.authentication.introduction:

Введение
========

``Zend_Auth`` предоставляет *API* для аутентификации и включает в себя
конкретные адаптеры для общих случаев применения.

Задачей ``Zend_Auth`` является **аутентификация**, но не
**авторизация**. Аутентификацию в общих чертах можно
характеризовать как процесс определения, действительно ли
сущность является тем, чем она претендует быть (то есть
идентификация), на основании некоторого набора учетных данных.
Авторизация же — процесс определения того, можно ли
предоставить сущности доступ или разрешить выполнить
действие — полностью вне сферы компетенции ``Zend_Auth``.
Дополнительную информацию об авторизации и контроле доступа в
Zend Framework смотрите в :ref:`Zend\\Permissions\\Acl <zend.acl>`.

.. note::

   Класс ``Zend_Auth`` реализует паттерн Синглтон — доступен только 
   один экзмепляр класса — через статический метод
   ``getInstance()``. Это означает, что с классом ``Zend_Auth``
   не будут работать ключевые слова **new** или **clone**. Вместо
   них используйте уже упомянутый метод ``Zend\Auth\Auth::getInstance()``.

.. _zend.authentication.introduction.adapters:

Адаптеры
--------

Адаптер ``Zend_Auth`` используется для аутентификации посредством
определенного сервиса, такого как *LDAP*, *СУРБД* или файлового
хранилища. Адаптеры могут значительно различаться, но
некоторые основные черты характерны для всех. Например, все
адаптеры ``Zend_Auth`` принимают учетные данные, выполняют запрос
к аутентификационному сервису и возвращают результат.

Каждый адаптер ``Zend_Auth`` реализует ``Zend\Auth\Adapter\Interface``. Этот
интерфейс определяет лишь один метод ``authenticate()``, который
и должен выполнять аутентификационный запрос. Адаптер должен быть настроен
до вызова ``authenticate()``: настройка включает в себя указание учетных
данных (например, логина и пароля) и определение специфичных для адаптера
БД значений, например, параметров подключения.

Ниже приведён пример адаптера, требующего установки логина и пароля для
аутентификации. Прочие детали, например, как происходит запрос к
аутентификационному сервису, опущены для краткости:

.. code-block:: php
   :linenos:

   class MyAuthAdapter implements Zend\Auth\Adapter\Interface
   {
       /**
        * Устанавливает логин и пароль для аутентификации
        *
        * @return void
        */
       public function __construct($username, $password)
       {
           // ...
       }

       /**
        * Выполняет попытку аутентификации
        *
        * @throws Zend\Auth\Adapter\Exception Если аутентификация не может быть выполнена
        * @return Zend\Auth\Result
        */
       public function authenticate()
       {
           // ...
       }
   }

Как указано в описании ``authenticate()``, он должен вернуть экземпляр
``Zend\Auth\Result`` (или унаследованный от него). Если по какой-либо
причине выполнение аутентификации невозможно, ``authenticate()``
должен вызвать исключение, производное от ``Zend\Auth\Adapter\Exception``.

.. _zend.authentication.introduction.results:

Результат аутентификации
------------------------

Метод ``authenticate()`` адаптера ``Zend_Auth`` возвращает экземпляр
``Zend\Auth\Result``, содержащий результат попытки аутентификации.
Объект ``Zend\Auth\Result`` заполняется адаптером при создании,
а следующие четыре метода представляют его базовый набор операций:

- ``isValid()`` — возвращает ``TRUE`` только в случае успешной попытки
  аутентификации.

- ``getCode()`` — возвращает значение одной из констант ``Zend\Auth\Result``,
  указывающее на успешную аутентификацию или тип возникшей ошибки.
  Его можно использовать в ситуации, когда разработчик хочет обрабатывать
  результаты попыток аутентификации по-раздельности. К примеру, он может
  вести детальную статистку всех попыток либо выводить нестандартные
  сообщения для удобства пользователей. Но при этом стоит учитывать риски
  предоставления пользователям слишком подробных сведений вместо
  стандартных сообщений о неудаче. Чуть более подробно о возвращаемых
  значениях насписано ниже.

- ``getIdentity()`` — возвращает идентификатор, полученный в результате
  аутентификации.

- ``getMessages()`` — возвращает массив сообщений об ошибках, возникших в
  процессе попытки аутентификации.

Разработчик может захотеть выполнить различные действия для разных результатов
попыток аутентификации. Например, можно счесть полезной блокировку аккаунта
после нескольких вводов неправильного пароля, бан IP-адреса после множества
попыток аутентификации с несуществующими данными или вывод настраиваемых
сообщений о результате аутентификации.
Определены следующие коды:

.. code-block:: php
   :linenos:

   Zend\Auth\Result::SUCCESS
   Zend\Auth\Result::FAILURE
   Zend\Auth\Result::FAILURE_IDENTITY_NOT_FOUND
   Zend\Auth\Result::FAILURE_IDENTITY_AMBIGUOUS
   Zend\Auth\Result::FAILURE_CREDENTIAL_INVALID
   Zend\Auth\Result::FAILURE_UNCATEGORIZED

Этот пример показывает, как можно по-разному обработать результат аутентификации,
используя значение кода:

.. code-block:: php
   :linenos:

   // в AuthController / loginAction
   $result = $this->_auth->authenticate($adapter);

   switch ($result->getCode()) {

       case Zend\Auth\Result::FAILURE_IDENTITY_NOT_FOUND:
           /** Выполнить действия при несуществующем идентификаторе **/
           break;

       case Zend\Auth\Result::FAILURE_CREDENTIAL_INVALID:
           /** Выполнить действия при некорректных учетных данных **/
           break;

       case Zend\Auth\Result::SUCCESS:
           /** Выполнить действия при успешной аутентификации **/
           break;

       default:
           /** Выполнить действия для остальных ошибок **/
           break;
   }

.. _zend.authentication.introduction.persistence:

Постоянное хранение идентификатора пользователя
-----------------------------------------------

Само собой, важно произвести аутентификацию запроса с учетными данными,
но так же важно сохранить идентификатор, избежав передачи учетных данных
вместе с каждым запросом.

Протокол сам по себе *HTTP* не поддерживает состояния, однако есть такие
технологии как куки (cookies) и сессии, поддерживающие одно и то же
состояние на стороне сервера в промежутке между несколькими запросами
к веб-приложению.

.. _zend.authentication.introduction.persistence.default:

Сохранение идентификатора по умолчанию в сессии PHP
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

По умолчанию ``Zend_Auth`` обеспечивает постоянное хранение идентификатора,
полученного в результате успешной попытки аутентификации, в *PHP* сессии.

При успешной попытке ``Zend\Auth\Auth::authenticate()`` запоминает идентификатор
в постоянном хранилище. По умолчанию ``Zend_Auth`` использует класс хранилища
``Zend\Auth\Storage\Session``, который в свою очередь использует
:ref:`Zend_Session <zend.session>`. Вместо него можно использовать
пользовательский класс, для этого нужно передать в ``Zend\Auth\Auth::setStorage()``
объект, реализующий ``Zend\Auth\Storage\Interface``.

.. note::

   Если автоматическое сохранение идентификатора не подходит для
   решаемой задачи, то разработчику следует отказаться от взаимодействия с
   классом ``Zend_Auth`` и использовать адаптер напрямую.

.. _zend.authentication.introduction.persistence.default.example:

.. rubric:: Изменение пространства имен в сессии

``Zend\Auth\Storage\Session`` использует пространство имен '``Zend_Auth``'. Оно
может быть переопределено передачей другого значения конструктору
``Zend\Auth\Storage\Session``, которое будет дальше передано конструктору
``Zend\Session\Namespace``. Это нужно сделать ещё до попытки аутентификации, так как
``Zend\Auth\Auth::authenticate()`` выполняет автоматическое сохранение
идентификатора.

.. code-block:: php
   :linenos:

   // Получаем синглтон Zend_Auth
   $auth = Zend\Auth\Auth::getInstance();

   // Устанавливаем 'someNamespace' вместо 'Zend_Auth'
   $auth->setStorage(new Zend\Auth\Storage\Session('someNamespace'));

   /**
    * @todo подготовка адаптера, $authAdapter
    */

   // Аутентификация, сохранение результата, и хранение идентификатора
   // при успехе.
   $result = $auth->authenticate($authAdapter);

.. _zend.authentication.introduction.persistence.custom:

Реализация пользовательского хранилища
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Иногда нужно использовать иной механизм хранения идентификаторов, отличающийся
от предоставляемого ``Zend\Auth\Storage\Session``. В таком случае можно реализовать
``Zend\Auth\Storage\Interface`` и передать экземпляр методу ``Zend\Auth\Auth::setStorage()``.

.. _zend.authentication.introduction.persistence.custom.example:

.. rubric:: Использование пользовательского хранилища

Чтобы использовать класс хранилища пользовательских идентификаторов, отличающийся
от ``Zend\Auth\Storage\Session``, реализовывается ``Zend\Auth\Storage\Interface``:

.. code-block:: php
   :linenos:

   class MyStorage implements Zend\Auth\Storage\Interface
   {
       /**
        * Возвращает  true, если хранилище пусто
        *
        * @throws Zend\Auth\Storage\Exception В случае если невозможно
        *                                     определить, пусто ли
        *                                     хранилище
        * @return boolean
        */
       public function isEmpty()
       {
           /**
            * @todo реализация
            */
       }

       /**
        * Возвращает содержимое хранилища
        *
        * Поведение неопределено, когда хранилище пусто.
        *
        * @throws Zend\Auth\Storage\Exception Если получение содержимого
        *                                     хранилища невозможно
        * @return mixed
        */
       public function read()
       {
           /**
            * @todo реализация
            */
       }

       /**
        * Записывает $contents в хранилище
        *
        * @param  mixed $contents
        * @throws Zend\Auth\Storage\Exception Если запись содержимого в
        *                                     хранилище невозможна
        * @return void
        */
       public function write($contents)
       {
           /**
            * @todo реализация
            */
       }

       /**
        * Очищает содержмое хранилища
        *
        * @throws Zend\Auth\Storage\Exception Если очищение хранилища
        *                                     невозможно
        * @return void
        */
       public function clear()
       {
           /**
            * @todo реализация
            */
       }
   }

Разумеется, экземпляр этого класса нужно передать в ``Zend\Auth\Auth::setStorage()`` 
ещё до попытки аутентификации:

.. code-block:: php
   :linenos:

   // Сказать Zend_Auth использовать пользовательский класс хранилища
   Zend\Auth\Auth::getInstance()->setStorage(new MyStorage());

   /**
    * @todo подготовка адаптера, $authAdapter
    */

   // Аутентификация, сохранение результата, и запоминание идентификатора
   // при успехе.
   $result = Zend\Auth\Auth::getInstance()->authenticate($authAdapter);

.. _zend.authentication.introduction.using:

Использование
-------------

Существует два пути использования адаптеров ``Zend_Auth``:

. косвенно через ``Zend\Auth\Auth::authenticate()``

. напрямую через метод адаптера ``authenticate()``

Следующий пример показывает, как использовать адаптер ``Zend_Auth``
через класс ``Zend_Auth``:

.. code-block:: php
   :linenos:

   // Получаем синглтон Zend_Auth
   $auth = Zend\Auth\Auth::getInstance();

   // Установка адаптера
   $authAdapter = new MyAuthAdapter($username, $password);

   // Попытка аутентификации, получение результата
   $result = $auth->authenticate($authAdapter);

   if (!$result->isValid()) {
       // Попытка неуспешна — вывести сообщения об ошибках
       foreach ($result->getMessages() as $message) {
           echo "$message\n";
       }
   } else {
       // Попытка успешна — идентификатор ($username) сохранен
       // в сессии
       // $result->getIdentity() === $auth->getIdentity()
       // $result->getIdentity() === $username
   }

Как показано в примере выше, после попытки аутентификации осталось
только проверить, существует ли идентификатор:

.. code-block:: php
   :linenos:

   $auth = Zend\Auth\Auth::getInstance();
   if ($auth->hasIdentity()) {
       // Идентификатор существует — получить его
       $identity = $auth->getIdentity();
   }

Для удаления идентификатора из постоянного хранилища просто
используйте метод ``clearIdentity()``. Обычно его задействуют при
реализации действия «Выйти»:

.. code-block:: php
   :linenos:

   Zend\Auth\Auth::getInstance()->clearIdentity();

Если использование постоянного хранилища а автоматическом режиме
не подходит, можно обойтись без ``Zend_Auth`` и использовать
класс адаптера напрямую. Непосредственное использование
адаптера включает в себя его настройку, создание экземпляра
и последующий вызов его метода ``authenticate()``. Особые настройки
для конкретного адаптера можно найти в его документации.
Следующий пример напрямую использует ``MyAuthAdapter``:

.. code-block:: php
   :linenos:

   // Подготовка адаптера
   $authAdapter = new MyAuthAdapter($username, $password);

   // Попытка аутентификации, сохранение результата
   $result = $authAdapter->authenticate();

   if (!$result->isValid()) {
       // Попытка неуспешна; вывести сообщения об ошибках
       foreach ($result->getMessages() as $message) {
           echo "$message\n";
       }
   } else {
       // Попытка успешна;
       // $result->getIdentity() === $username
   }


