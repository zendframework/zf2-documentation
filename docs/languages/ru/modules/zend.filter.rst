.. _zend.filter.introduction:

Введение
========

Компонента ``Zend_Filter`` предоставляет набор наиболее часто
используемых фильтров данных. Она также предоставляет простой
механизм формирования цепочек фильтров данных, с
использованием которого одни и те же данные могут
обрабатываться несколькими фильтрами в порядке, заданном
пользователем.

.. _zend.filter.introduction.definition:

Что есть фильтр?
----------------

В материальном мире фильтр обычно используется для удаления
нежелательных частей ввода. Желаемые части ввода проходят
сквозь фильтр и являются выводом фильтра. В таких сценариях
фильтр является опрератором, который выделяет подмножество
ввода. Этот тип фильтра полезен для веб-приложений - удаление
недопустимого ввода, лишних пробельных символов и т.д.

Это базовое определение фильтра может быть расширено
включением общих преобразований ввода. Часто встречающееся в
веб-приложениях преобразование - экранирование сущностей HTML
(HTML entities). Например, если поле формы автоматически заполняется
ненадежными данными (например, данными из веб-броузера), то это
значение не должно включать в себя сущности HTML, либо эти
сущности должны быть экранированы, для предотвращения
нежелательного поведения и угроз безопасности. В соответствии
с этими требованиями сущности HTML должны быть удалены или
экранированы - выбор подхода зависит от ситуации. Фильтр,
который экранирует сущности HTML, тем не менее, преобразовывает
ввод (например, "*&*" преобразовывается в "*&amp;*"). Поддержка таких
случаев использования важна для веб-разработчиков и
"фильтрация" в контексте использования ``Zend_Filter`` подразумевает
выполнение некоторых преобразований над входными данными.

.. _zend.filter.introduction.using:

Основы использования фильтров
-----------------------------

Такое определение фильтра дает основу для ``Zend_Filter_Interface``,
который требует от классов фильтров реализации одного метода
с именем *filter()*.

Ниже приведен пример использования фильтра с двумя вариантами
входных данных - амперсандом (*&*) и двойными кавычками (*"*).

   .. code-block:: php
      :linenos:

      $htmlEntities = new Zend_Filter_HtmlEntities();

      echo $htmlEntities->filter('&'); // &
      echo $htmlEntities->filter('"'); // "



.. _zend.filter.introduction.static:

Использование статического метода get()
---------------------------------------

Каждый раз загружать нужный класс фильтра и создавать его
экземпляр довольно неудобно, поэтому был создан статический
метод *Zend_Filter::get()*, который можно использовать как
альтернативный способ вызова. Первым агрументом этого метода
является значение входных данных, которое требуется передать
методу *filter()*. Вторым аргументом является строка, которая
соответствует базовому имени класса фильтра относительно
пространства имен ``Zend_Filter``. Метод *get()* автоматически загружает
класс, создает его экземпляр и применяет метод *filter()* к входным
данным.

   .. code-block:: php
      :linenos:

      echo Zend_Filter::get('&', 'HtmlEntities');



Можно также передавать массив аргументов для конструктора,
если это необходимо для используемого класса фильтра.

   .. code-block:: php
      :linenos:

      echo Zend_Filter::get('"', 'HtmlEntities', array(ENT_QUOTES));



Использование метода *get()* может быть удобным для единичного
вызова фильтра. Но если нужно пропустить через один и тот же
фильтр несколько значений, то более эффективным будет
создавать экземпляр фильтра и вызывать его метод *filter()*, как
это было показано в первом примере.

``Zend_Filter_Input`` также позволяет инстанцировать и запускать
несколько фильтров и валидаторов для обработки наборов
данных. Более подробную информацию читайте в :ref:` <zend.filter.input>`.


