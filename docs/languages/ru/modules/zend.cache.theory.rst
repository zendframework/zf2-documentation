.. _zend.cache.theory:

Теория кэширования
==================

Есть три ключевых понятия в ``Zend_Cache``. Первое — уникальный
идентификатор (строка), который служит для идентификации
записей кэша. Второе — это директива **'lifetime'**, которую вы могли
видеть в предыдущих примерах; она определяет, в течение какого
времени кэшируемый ресурс считается "свежим". Третье понятие —
условное исполнение, используемое для того, чтобы части вашего
кода могли быть пропущены целиком, этим повышается
производительность. Основной метод фронтэнда (например,
``Zend_Cache_Core::get()``) всегда спроектирован так, чтобы возвращать
``FALSE`` при промахе кэша, если это имеет смысл для данного
фронэнда. Это дает конечным пользователям возможность
включать части кода, которые нужно кэшировать (и затем
пропускать) в операторы **if(){ ... }**, где условием является сам
метод ``Zend_Cache``. Но в конце этих блоков вы должны сохранять то,
что было сгенерировано (например, методом ``Zend_Cache_Core::save()``).

.. note::

   Для некоторых фронтэндов включение условного исполнения в
   код не нужно, так как вся логика уже реализована в них
   (например, **Function**).

.. note::

   "Попадание в кэш" — термин для определения того состояния,
   когда запись кэша найдена, является корректной и "свежей"
   (другими словами, для которой не закончился срок действия).
   Иначе имеет место "промах кэша". Когда происходит "промах
   кэша", вы должны сгенерировать свои данные, которые
   помещаются в кэш. С другой стороны, если есть "попадание", то
   бэкэнд автоматически извлечет запись из кэша.

.. _zend.cache.factory:

Фабричный метод Zend_Cache
--------------------------

Корректным способом создания рабочего экземпляра фронтэнда
``Zend_Cache`` является код показанный в следующем примере:

.. code-block:: php
   :linenos:

   // Выбираем бэкэнд (например, 'File' или 'Sqlite'...)
   $backendName = '[...]';

   // Выбираем фронтэнд (например, 'Core', 'Output', 'Page'...)
   $frontendName = '[...]';

   // Устанавливаем массив опций для выбранного фронтэнда
   $frontendOptions = array([...]);

   // Устанавливаем массив опций для выбранного бэкэнда
   $backendOptions = array([...]);

   // Создаем экземпляр
   // (два последних аргумента являются необязательными)
   $cache = Zend_Cache::factory($frontendName,
                                $backendName,
                                $frontendOptions,
                                $backendOptions);

В последующих примерах мы предполагаем, что переменная ``$cache``
содержит инстанцированный, как показано в примере, фронтэнд, и
что вы понимаете, как передавать параметры выбранному вами
бэкэнду.

.. note::

   Всегда используйте ``Zend_Cache::factory()`` для получения экземпляров
   фронтэнда. Непосредственно созданные экземпляры фронтэндов
   и бэкэндов будут работать не так, как ожидается.

.. _zend.cache.tags:

Добавление тегов к записям
--------------------------

Теги являются средством категоризации записей кэша. Когда вы
производите сохранение в кэш методом ``save()``, то можете
установить массив тегов к данной записи. После этого вы можете
удалить все записи кэша, помеченные данным тегом (тегами).

.. code-block:: php
   :linenos:

   $cache->save($huge_data, 'myUniqueID', array('tagA', 'tagB', 'tagC'));

.. note::

   Метод ``save()`` принимает также необязательный четвертый
   параметр: ``$specificLifetime``. Если он не равен ``FALSE``, то
   устанавливается время жизни текущей записи кэша.

.. _zend.cache.clean:

Очистка кэша
------------

Для того, чтобы удалить или сделать недействительной запись с
определенным идентификатором, вы можете использовать метод
``remove()``:

.. code-block:: php
   :linenos:

   $cache->remove('idToRemove');

Для того, чтобы одновременно удалить или сделать
недействительными несколько записей кэша, вы можете
использовать метод ``clean()``. Например, чтобы удалить все записи
кэша:

.. code-block:: php
   :linenos:

   // удаление всех записей
   $cache->clean(Zend_Cache::CLEANING_MODE_ALL);

   // удаление только устаревших записей
   $cache->clean(Zend_Cache::CLEANING_MODE_OLD);

Если вы хотите удалить записи кэша, помеченные тегами 'tagA' и
'tagC':

.. code-block:: php
   :linenos:

   $cache->clean(
       Zend_Cache::CLEANING_MODE_MATCHING_TAG,
       array('tagA', 'tagC')
   );

Если вы хотите удалить записи кэша, не помеченные тегами 'tagA' и
'tagC': If you want to remove cache entries not matching the tags 'tagA' or 'tagC':

.. code-block:: php
   :linenos:

   $cache->clean(
       Zend_Cache::CLEANING_MODE_NOT_MATCHING_TAG,
       array('tagA', 'tagC')
   );

Если вы хотите удалить записи кэша, помеченные тегами 'tagA' или
'tagC':

.. code-block:: php
   :linenos:

   $cache->clean(
       Zend_Cache::CLEANING_MODE_MATCHING_ANY_TAG,
       array('tagA', 'tagC')
   );

Доступные режимы очищения: ``CLEANING_MODE_ALL`` (удалить все),
``CLEANING_MODE_OLD`` (удалить устаревшие), ``CLEANING_MODE_MATCHING_TAG`` (удалить
помеченные тегом) и ``CLEANING_MODE_NOT_MATCHING_TAG`` (удалить не помеченные
тегом). Последние два, как ясно из названия, передаются вместе с
массивом тегов.


